# Вопросы на тему программирования

Софт скилы
----------

1. Скажите мне, как бы вы преодолели ситуацию, когда команда плохо работает, потому что члены не ладят.
2. Что для вас значит командный дух и как бы вы его построили?
3. Как бы вы справились с товарищем по команде, который не выполнял свою долю работы?
4. Вы знаете, что ваш менеджер на 100% неправ в чем-то. Что вы сделаете?
5. Как вы относитесь к делегированию обязанностей в команде?
6. С каким самым трудным изменением вы столкнулись в своей карьере?
7. Как вы меняете свое расписание, если происходит что-то незапланированное?
8. Приведите пример, когда вы успешно решили проблему.
9. Приведите пример, когда вам приходилось проявлять творческий подход или нестандартность в решении проблемы.
10. Как вы сохраняете мотивацию, работая в одиночку над проектом?
11. Чего вы надеетесь достичь в течение первых шести месяцев работы в нашей компании?
12. Вам нравится ответственность за принятие решений или вы бы предпочли оставить это кому-то другому?
13. Что заставит вас бросить работу в первый месяц?

Python
------
**1. В чем разница между списком и кортежем?**

Ответ:
<ul>
    <li>Список можно изменить после создания.</li>
    <li>Кортеж нельзя изменить после создания.</li>
    <li>Кортеж хешируется, значит может использоваться как ключ в словаре</li>
    <li>Список не хешируется, значит не может быть использован как ключ в словаре</li>
</ul>

**2. Как выполняется интерполяция строк?**

Ответ:

```python
name = 'Chris'

# 1. f strings
print(f'Hello {name}')

# 2. % operator
print('Hey %s %s' % (name, name))

# 3. format
print(
 "My name is {}".format((name))
)
```

**3. В чем разница между "is" и "==" ?**

Ответ:

is проверяет идентичность, а == проверяет равенство.

```python
a = [1,2,3]
b = a
c = [1,2,3]
...
print(a == b)
print(a == c)
#=> True
#=> True
...
print(a is b)
print(a is c)
#=> True
#=> False
...
print(id(a))
print(id(b))
print(id(c))
#=> 4369567560
#=> 4369567560
#=> 4369567624
```

**4. Что такое декоратор?**

Ответ:

Декораторы – это обертка вокруг функций (или классов) в Python, которая меняет способ работы этой функции. Декоратор
абстрагирует свой собственный функционал.

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        print("Hello, World!")
        func(*args, **kwargs)
    return wrapper

@decorator
def main():
    print("I'm here!")


main()
...
#=> Hello, World!
#=> I'm here!
```

**5. Объясните, как работает функция reduce**

Ответ:

reduce принимает функцию и последовательность — и проходит по этой последовательности. На каждой итерации в функцию
передаются как текущий элемент, так и выходные данные предыдущего элемента. В конце концов, возвращается одно значение:

```python
from functools import reduce


def add_three(x,y):
    return x + y
    
    
li = [1,2,3,5]

print(reduce(add_three, li))
...
#=> 11
```

**6. Объясните, как работает функция filter**

Ответ:

Функция делает буквально то, о чем говорит ее название: она фильтрует элементы в последовательности.

Каждый элемент передается функции, которая включает его в последовательность, если по условию получает True, и
отбрасывает в случае False:

```python 
def add_three(x):
    if x % 2 == 0:
        return True        
    return False

li = [1,2,3,4,5,6,7,8]

print([i for i in filter(add_three, li)])
...
#=> [2, 4, 6, 8]
```

**7. Переменные в Python передаются по ссылке или по значению?**

Ответ:

В Python аргументы передаются по ссылке, т. е. передается ссылка на реальный объект.

Но есть два вида передачи объекта в
аргументах.

* По значению: Передается копия реального объекта. Изменение значения копии объекта не приведет к изменению
  значения исходного объекта.
* По ссылке: Передается ссылка на реальный объект.

**8. В чем разница между глубокой и мелкой копиями?**

Ответ:

* Глубокие копирования хранят копию значений объекта перечисляется, тогда как мелкая копия историй ссылка на исходный
  адрес памяти
* Глубокая копия не отражает изменений, внесенных в новый / скопированный объект в исходном объекте; тогда как
  неглубокая копия делает

Полное копирование: ```copy.deepcopy```

```python
import copy 

result_A = [[90, 85, 82], [72, 88, 90]]
result_B = copy.deepcopy(result_A)

result_B[0][0] = 30 

print(result_A) 
print(result_B) 
...
[[90, 85, 82], [72, 88, 90]] 
[[30, 85, 82], [72, 88, 90]] 
```

Поверхностное копирование: ```copy.copy```

```python
import copy 
 
result_A = [[90, 85, 82], [72, 88, 90]]
result_B = copy.copy(result_A) 
 
result_B[0][0] = 30 
 
print(result_A) 
print(result_B)
... 
[[30, 85, 82], [72, 88, 90]] 
[[30, 85, 82], [72, 88, 90]] 
```

**9. В чем разница между модулем и пакетом?**

Ответ:

Модуль — это файл или набор файлов, которые импортируются вместе:

```python
import sklearn
```

Пакет — это каталог с модулями:

```python
from sklearn import cross_validation
```

Таким образом, пакеты — это модули, но не все модули являются пакетами.

Django
------

**1. Что такое Django?**

Ответ:

Django - это платформа веб-разработки с открытым исходным кодом, основанная на языке Python, позволяющая разработчикам
Python создавать веб-сайты, управляемые базами данных. Использует шаблон проектирования MVC.
Он был представлен в 2003 году в журнале Lawrence Journal - всемирной газете.

Этот популярный фреймворк поддерживается некоммерческой организацией Django Software Foundation (DSF). Позже, в 2005
году, Django стал общедоступным под лицензией BSD с 3 пунктами.

**2. В чем преимущества Django?**

Ответ:

Большинство разработчиков предпочитают Django из-за его доминирования на рынке, поскольку он демонстрирует высокие
вычислительные и статистические возможности. Ниже приведены некоторые из преимуществ Django:

* Django следует принципу Python "батарейки в комплекте". Python обычно называют "включенными батареями", потому что он
  имеет унифицированную стандартную библиотеку, помогающую разработчикам использовать готовые пакеты для добавления
  функций в веб-проект.
* Большинство пакетов в стандартной библиотеке Python имеют открытый исходный код. С помощью этих пакетов вы даже можете
  реализовать аутентификацию, взаимодействие с администратором, управление сеансами и другие расширенные функциональные
  возможности.
* Python и Django являются основными технологиями в ИТ-гигантах, Интернете вещей (IoT) и компаниях с "голубыми фишками".
  Поэтому изучение этого поможет вам построить прибыльную карьеру.
* Безопасность - еще одно преимущество использования платформы Django. Приложения, разработанные на Django, защищены от
  SQL-инъекций, взлома кликов, атак XSS и CSRF и т. Д.
* Встроенный язык шаблонов Django способствует процессу создания приложений.
* Django позволяет разработчикам создавать приложения и настраивать фреймворки на ходу. Кроме того, он предлагает
  поддержку внешних библиотек и пакетов. Django фокусируется на явном программировании, позволяя разработчикам создавать
  приложения, требующие частых изменений.
* Это помогает ускорить разработку и, таким образом, используется большинством компаний. Если конфигурация правильная,
  вы можете использовать Django для оптимизации веб-приложений.
* В Django есть REST framework, библиотека python, которая помогает разрабатывать API для многих приложений. Используя
  эти API, вы можете добавлять расширенные функциональные возможности в свои приложения.
* Django поставляется с возможностями ML и библиотеками, такими как PyTorch, NumPy и др.

**3. Каковы недостатки Django?**

Ответ:

Несмотря на множество преимуществ, разработчикам по-прежнему сложно осуществить переход. Ниже приведены некоторые
недостатки использования фреймворка Django:

* Позволяет создавать только одно уровневые приложения.
* Не подходит для небольших приложений.
* Требует большего понимания структуры.

**4. Опишите архитектуру Django.**

Ответ:

Django следует архитектуре Model-View-Template (MVT), основанной на популярном архитектурном шаблоне
Model-View-Controller (MVC), которому следуют популярные веб-фреймворки, такие как Ruby on Rails, Laravel и др.

Архитектура Django Model-View-Template делит все приложение на три основных логических компонента:

* Модель
* Вид
* Шаблон

Все эти три компонента отвечают за обработку различных аспектов веб-приложения.

**Модель**: модели обрабатывают схему базы данных для веб-приложений. Он поддерживает и представляет полные данные
приложения в базе данных. Реляционной базой данных по умолчанию, используемой моделью, является SQLite, которая обычно
используется в разработке, но в производстве мы можем использовать MySQL и Postgres.

**Просмотр**: компонент просмотра управляет всей логикой приложения, которую мы хотим отобразить в браузере
пользователя. В
Django представление служит связующим звеном между моделями и шаблонами. В представлениях мы можем извлекать данные из
моделей и отображать их в шаблоне.

**Шаблон**: Компонент шаблона представляет собой набор статических частей приложения, таких как HTML, CSS, JavaScript и
файлы изображений. Представление использует шаблон в качестве основы, на которой должны быть представлены данные, потому
что в конце веб-приложение использует статические файлы для представления содержимого в браузере пользователя.

**5. Что происходит, когда веб-сайт Django получает запрос?**

Ответ:

Кратко

Всякий раз, когда пользователь вводит URL-адрес в браузере, сервер Django получает запрос. Сервер ищет URL-адрес в своей
URL-конфигурации. Если сервер найдет там совпадение, он вернет соответствующую функцию просмотра.

Затем для получения данных делается запрос к модели приложения. Если нужно передать какие-либо данные, передайте их в
соответствующий шаблон. После этого шаблон отображается в браузере. Если процесс не работает должным образом,
пользователь получит страницу с ошибкой “404”.

**6. Объясните ORM на Django.**

Ответ:

ORM расшифровывается как Object-relational mapper, специальный функциональный инструмент Django. Этот инструмент
помогает разработчикам взаимодействовать с базой данных более похожим на Python способом. Он действует как абстракция
между моделями и базой данных, где хранятся основные данные.

Используя ORM, вы можете извлекать, сохранять и удалять данные из базы данных без необходимости писать для них
какой-либо SQL-код. Этот инструмент поможет устранить многие лазейки, поскольку он позволяет вам сохранять контроль над
вашим кодом и разработан на Python.

Не имеет значения, является ли база данных SQLite, MySQL, Postgre или Oracle, ORM гарантирует, что разработчик пишет
один и тот же код для всех баз данных.

Django использует ORM, известный как Django ORM, он использует классы, унаследованные от моделей.Modle, для создания
таблиц в любой базе данных.

Единственное, что нам нужно изменить, это настройки базы данных в setting.py досье.

**7. Что такое функция django.shortcuts.render?**

Ответ:

Когда функция просмотра возвращает веб-страницу как HttpResponse вместо простой строки, используйте функцию render() .
Эта функция позволит разработчикам передавать словарь данных с помощью шаблона. Затем эта функция будет использовать
механизм создания шаблонов для объединения шаблона со словарем данных.

После этого эта функция вернет HttpResponse с отображаемым текстом, который возвращается моделями. Таким образом, эта
функция сэкономит много времени разработчикам и позволит им использовать разные механизмы создания шаблонов.

**8. Что такое Middleware?**

Ответ:

**Middleware** - это система хуков для обработки запросов/ответов в Django. Это легкая, низкоуровневая система
«плагинов»
для глобального изменения входных или выходных данных Django. Каждый компонент промежуточного ПО отвечает за выполнение
определенной функции. Например, Django включает компонент промежуточного ПО, AuthenticationMiddleware, который связывает
пользователей с запросами с помощью сессий.

**9. Что такое сигналы в Django?**

Ответ:

**Сигналы** - это фрагменты кода, которые содержат информацию о том, что происходит. Вы можете использовать диспетчера
для
отправки сигналов и прослушивания этих сигналов.

Сигналы становятся очень полезными, когда мы хотим что-то сделать с данными, до или после того, как произойдет
определенное событие.

Вот список событий, на которых мы можем использовать сигналы Django:

* функция pre_save() срабатывает перед функцией save().
* post_save() запускается после сохранения ().
* запуск функции pre_delete() перед удалением().
* post_delete() запускается после delete().
* m2m_changed() срабатывает при изменении поля ManyToMany.
* request_started() запускается, когда django запускает HTTP-запрос.
* request_finished() запускается, когда django завершает HTTP-запрос.

Пример

```python
from .models import Blog

from django.core.mail import send_mail
from django.db.models.signals import post_save


@receiver(post_save, sender=Blog)
def create_profile(sender, instance, created, **kwargs):
    if created:
        blog_title = instance.title
        send_mail("Subject", "Message", "from_email", ['toemail@.com'])
```

**10. Что такое микширование в Django?**

Ответ:

Mixin - это тип множественного наследования, который объединяет поведение и атрибуты более чем одного родительского
класса. Это обеспечивает отличный способ повторного использования кода из нескольких классов.

Например, общие представления на основе классов имеют миксин, называемый TemplateResponseMixin. Этот микс используется
для определения метода render_to_response(). Когда вы объединяете его с классом, присутствующим в представлении, в
результате получается класс TemplateView.

Единственным недостатком mixin является то, что становится трудно анализировать, что делает дочерний класс и какие
методы переопределять, если его код разбросан между несколькими классами.

**11. Каковы стратегии кэширования в Django?**

Ответ:

Кэширование подразумевает сохранение выходных данных вычислений, чтобы избежать повторного выполнения одних и тех
же вычислений. Django поставляется с надежной системой кэширования, помогающей создавать динамические страницы. Таким
образом, отпадает необходимость многократной оценки страниц для каждого запроса. В следующей таблице приведены некоторые
из важных стратегий кэширования:

<table>
  <tr>
    <th>Стратегии</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>Memcached</td>
    <td>Это кэш-сервер на основе памяти.</td>
  </tr>
  <tr>
    <td>Filesystem caching</td>
    <td>Эта стратегия кэширования помогает кэшировать значения, хранящиеся в виде отдельных файлов в сериализованном порядке.</td>
  </tr>  
  <tr>
    <td>Local-memory caching</td>
    <td>Это кэш по умолчанию, и он используется, если вы не указали какой-либо другой. Это кэш для каждого процесса и потокобезопасный.</td>
  </tr>
  <tr>
    <td>Database caching</td>
    <td>В базе данных хранятся данные кэша.</td>
  </tr>
</table>

**12. Что такое manage.py файл в Django?**

Ответ:

Всякий раз, когда вы создаете проект, manage.py файл создается автоматически. Это утилита командной строки, помогающая
вам взаимодействовать с вашим проектом Django. Он выполняет ту же работу, что и Django-admin, и устанавливает переменную
среды DJANGO_SETTINGS_MODULE так, чтобы она указывала на настройки вашего проекта. Лучше, если вы используете manage.py
вместо Django-admin, если вы работаете над одним проектом.

**13. Каков цикл ответов в Django?**

Ответ:

Всякий раз, когда пользователь запрашивает веб-страницу, Django создает объект HttpRequest, содержащий важные метаданные
об этом запросе. После этого Django загрузит конкретное представление, передав HttpRequest в качестве первого аргумента
функции просмотра. Затем каждое представление возвращает объект HttpResponse.

![Example](https://lh6.googleusercontent.com/tERwVkYqzL5WbQAEZODCywIeT4JjoidLu7hjrZj5NG_R-k6mu3On7tEl3elrbS7K4EWw-uSUvOj1rCQ_rthHfMBGATIBUHElka9t7q8YudMuj1vT7Myet620XZFVtAGpUfehYby8)

Ниже приведены шаги, которые выполняются при получении запроса Django:

* Во-первых, settings.py загружается файл, содержащий различные классы промежуточного программного обеспечения
* Все классы промежуточного программного обеспечения выполняются в том же порядке, в котором они упоминаются
* Теперь запрос будет перемещен на URL-маршрутизатор. URL-маршрутизатор получает URL-путь из запроса, а затем пытается
  сопоставить с заданными URL-путями в urls.py .
* После сопоставления он вызывает эквивалентную функцию просмотра, откуда генерируется соответствующий ответ.
* Теперь ответ проходит через промежуточное программное обеспечение response и отправляется обратно клиенту / браузеру

**14. В чем разница между select_related и prefetch_related?**

<table class="c24">
  <tbody>
    <tr>
      <td>
        <p>select_related()</p>
      </td>
      <td>
      <p>prefetch_related()</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>Функция select_related() выполняет поиск набора запросов, она добавляет дополнительные данные из ForeignKey в QuerySet.</p>
      </td>
      <td>
        <p>Функция prefetch_related() - это еще один поиск для набора запросов, он добавляет дополнительные данные из ForeignKey, OneToOne и в OneToOne в набор запросов возврата.</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>Это уменьшает фоновый SQL-запрос с использованием операторов JOIN.</p>
      </td>
      <td>
        <p>Он использует SQL joins и команду SELECT, чтобы уменьшить сложный набор запросов.</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>Это работает, когда мы выбираем отдельные объекты.</p>
      </td>
      <td>
        <p>Он используется для выбора набора из нескольких объектов.</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>Пример</p>
        <p>&nbsp;</p>
        <pre>queryset = Blog.objects.select_related(<span>'Author'</span>).all()</pre>
        <p>&nbsp;</p>
        <p>&nbsp;</p>
      </td>
      <td>
        <p>Пример</p>
        <p>&nbsp;</p>
        <pre>queryset = Blog.objects.prefetch_related(<span>'Categories'</span>).all()</pre>
        <p>&nbsp;</p>
        <p>&nbsp;</p>
      </td>
    </tr>
  </tbody>
</table>

Пример:

```python
from django.db import models


class Country(models.Model):
   country_name = models.CharField(max_length=5)
   
   
class State(models.Model):
   state_name = models.CharField(max_length=5)
   country = model.ForeignKey(Country)
   
   
>> states = State.objects.select_related('country').all()
>> for state in states:
...   print(state.state_name)  

#=> SELECT state_id, state_name, country_name FROM State INNER JOIN Country ON (State.country_id = Country.id)

>> country = Country.objects.prefetch_related('state').get(id=1)
>> for state in country.state.all():
...   print(state.state_name)

#=> SELECT id, country_name FROM country WHERE id=1;
#=> SELECT state_id, state_name WHERE State WHERE country_id IN (1);
```

**15. Что такое FBV и CBV?**

Ответ:

* FBV（function base views）- Это использование функции в представлении для обработки запроса.
* CBV（class base views）- Это использование класса в представлении для обработки запроса.

**16. В чём разница между файлом cookie и сеансом**

Ответ:

* **Cookie** - это пара "ключ-значение", хранящаяся в браузере, которая может использоваться для аутентификации
  пользователя.
* **Session** - сохранить информацию о сеансе пользователя на сервере, значение ключа - это случайно сгенерированная
  строка, а значение value - это содержимое сеанса.
  использует файлы cookie для сохранения случайной строки каждого пользователя в браузере пользователя.

**17. Где хранятся сессии в Django?**

Ответ:

Сессия в Django по умолчанию сохраняется в базе данных: таблица django_session

**18. Что такое WSGI?**

Ответ:

WSGI - это метод обработки, предписанный Python при обработке HTTP-запросов. Если приходит HTTP-запрос, есть
соответствующая функция обработки для обработки и возврата результата. WSGI указывает, как выглядят параметры этой
функции обработки и как выглядит результат ее возврата? Что касается имени и логики обработки функции обработки, это не
имеет значения. Проще говоря, WSGI определяет формат ввода и вывода функции обработки.

**19. Что такое csrf token?**

Ответ:

Тег {% csrf_token %} содержит встроенную в Django функцию защиты от подделки межсайтовых запросов (CSRF) (документация
Django). Обычно этот тег добавляется в каждый элемент, для которого используются методы запросов POST, PUT или delete,
такой как форма. С помощью функции отображения в шаблон (render) затем вставляются необходимые средства защиты.

**20. Что вам больше всего нравится в Django?**

Ответ: по желанию

**21. Что вам больше всего не навится в Django?**

Ответ: по желанию

SQL
---

**1. Что подразумевается под СУБД? Какие существуют типы СУБД?**

Ответ:

База данных — структурированная коллекция данных. Система управления базами данных (СУБД) — программное обеспечение,
которое взаимодействует с пользователем, приложениями и самой базой данных для сбора и анализа данных. СУБД позволяет
пользователю взаимодействовать с базой данных. Данные, хранящиеся в базе данных, могут быть изменены, извлечены и
удалены. Они могут быть любых типов, таких как строки, числа, изображения и т. д

**Существует два типа СУБД**:

* Реляционная система управления базами данных: данные хранятся в отношениях (таблицах). Пример — MySQL.
* Не реляционная система управления базами данных: не существует понятия отношений, кортежей и атрибутов. Пример —
  Mongo.

**2. В чем разница между SQL и MySQL?**

Ответ:

SQL — стандартный язык структурированных запросов (Structured Query Language) на основе английского языка, тогда как
MySQL — система управления базами данных.

SQL — язык реляционной базы данных, который используется для доступа и управления данными,
MySQL — реляционная СУБД (система управления базами данных), так же как и SQL Server, Informix и т. д.

**3. Из каких подмножеств состоит SQL?**

Ответ:

* DDL (Data Definition Language, язык описания данных) — позволяет выполнять различные операции с базой данных, такие
  как CREATE (создание), ALTER (изменение) и DROP (удаление объектов).
* DML (Data Manipulation Language, язык управления данными) — позволяет получать доступ к данным и манипулировать ими,
  например, вставлять, обновлять, удалять и извлекать данные из базы данных.
* DCL (Data Control Language, язык контролирования данных) — позволяет контролировать доступ к базе данных. Пример —
  GRANT (предоставить права), REVOKE (отозвать права).

**4. Что такое TRUNCATE и чем эта команда отличается от DELETE?**

Ответ:

<table>
  <thead>
    <tr>
      <th>DELETE</th>
      <th>TRUNCATE</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Используется для удаления строки в таблице</td>
      <td>Используется для удаления всех строк из таблицы</td>
    </tr>
    <tr>
      <td>Вы можете восстановить данные после удаления</td>
      <td>Вы не можете восстановить данные (прим. перевод.: операции логируются по разному, но в SQL Server есть возможность сделать откат) транзакции)</td>
    </tr>
    <tr>
      <td>DML-команда</td>
      <td>DDL-команда</td>
    </tr>
    <tr>
      <td>Медленнее, чем оператор TRUNCATE</td>
      <td>Быстрее</td>
    </tr>
  </tbody>
</table>

**5. Что такое соединения в SQL?**

Ответ:

Для соединения строк из двух или более таблиц на основе связанного между ними столбца используется оператор JOIN. Он
используется для объединения двух таблиц или получения данных оттуда. В SQL есть 4 типа соединения, а именно:

* Inner Join (Внутреннее соединение)
* Right Join (Правое соединение)
* Left Join (Левое соединение)
* Full Join (Полное соединение)

**6. В чем разница между типом данных CHAR и VARCHAR в SQL?**

Ответ:

И Char, и Varchar служат символьными типами данных, но varchar используется для строк символов переменной длины, тогда
как Char используется для строк фиксированной длины. Например, char(10) может хранить только 10 символов и не сможет
хранить строку любой другой длины, тогда как varchar(10) может хранить строку любой длины до 10, т.е. например 6, 8 или
3

**7. Что такое первичный ключ (Primary key)?**

Ответ:

Первичный ключ — столбец или набор столбцов, которые однозначно идентифицируют каждую строку в таблице.
Однозначно идентифицирует одну строку в таблице
Нулевые (Null) значения не допускаются

**8. Что такое ограничения (Constraints)?**

Ответ:

Ограничения (constraints) используются для указания ограничения на тип данных таблицы. Они могут быть указаны при
создании или изменении таблицы. Пример ограничений:

* NOT NULL
* CHECK
* DEFAULT
* UNIQUE
* PRIMARY KEY
* FOREIGN KEY

**9. Что такое уникальный ключ (Unique key)?**

Ответ:

* Однозначно идентифицирует одну строку в таблице.
* Допустимо множество уникальных ключей в одной таблице.
* Допустимы NULL-значения (прим. перевод.: зависит от СУБД, в SQL Server значение NULL может быть добавлено только один
  раз в поле с UNIQUE KEY).

**10. Что подразумевается под целостностью данных?**

Ответ:

Целостность данных определяет точность, а также согласованность данных, хранящихся в базе данных. Она также определяет
ограничения целостности для обеспечения соблюдения бизнес-правил для данных, когда они вводятся в приложение или базу
данных.

**11. В чем разница между кластеризованным и некластеризованным индексами в SQL?**

Ответ:

Различия между кластеризованным и некластеризованным индексами в SQL:

* Кластерный индекс используется для простого и быстрого извлечения данных из базы данных, тогда как чтение из
  некластеризованного индекса происходит относительно медленнее.
* Кластеризованный индекс изменяет способ хранения записей в базе данных — он сортирует строки по столбцу, который
  установлен как кластеризованный индекс, тогда как в некластеризованном индексе он не меняет способ хранения, но
  создает
  отдельный объект внутри таблицы, который указывает на исходные строки таблицы при поиске.
* Одна таблица может иметь только один кластеризованный индекс, тогда как некластеризованных у нее может быть много.

**12. Что такое денормализация и что вы подразумеваете под денормализацией?**

Ответ:

**Денормализация** — техника, которая используется для преобразования из высших к низшим нормальным формам. Она помогает
разработчикам баз данных повысить производительность всей инфраструктуры, поскольку вносит избыточность в таблицу. Она
добавляет избыточные данные в таблицу, учитывая частые запросы к базе данных, которые объединяют данные из разных таблиц
в одну таблицу.

**13. Что такое индекс?**

Ответ:

Индексы относятся к методу настройки производительности, позволяющему быстрее извлекать записи из таблицы. Индекс
создает отдельную структуру для индексируемого поля и, следовательно, позволяет быстрее получать данные.

**14. Опишите различные типы индексов.**

Ответ:

Есть три типа индексов, а именно:

* Уникальный индекс (Unique Index): этот индекс не позволяет полю иметь повторяющиеся значения, если столбец
  индексируется уникально. Если первичный ключ определен, уникальный индекс может быть применен автоматически.
* Кластеризованный индекс (Clustered Index): этот индекс меняет физический порядок таблицы и выполняет поиск на основе
  значений ключа. Каждая таблица может иметь только один кластеризованный индекс.
* Некластеризованный индекс (Non-Clustered Index): не изменяет физический порядок таблицы и поддерживает логический
  порядок данных. Каждая таблица может иметь много некластеризованных индексов.

**15. Что такое нормализация и каковы ее преимущества?**

Ответ:

Нормализация — процесс организации данных, цель которого избежать дублирования и избыточности.

Некоторые из преимуществ:

* Лучшая организация базы данных
* Больше таблиц с небольшими строками
* Эффективный доступ к данным
* Большая гибкость для запросов
* Быстрый поиск информации
* Проще реализовать безопасность данных
* Позволяет легко модифицировать
* Сокращение избыточных и дублирующихся данных
* Более компактная база данных
* Обеспечивает согласованность данных после внесения изменений**

**16. Что такое свойство ACID в базе данных?**

Ответ:

**ACID** означает:

* **Atomicity** - Атомарность
* **Consistency** - Согласованность
* **Isolation** - Изолированность
* **Durability** - Долговечность

Он используется для обеспечения надежной обработки транзакций данных в системе базы данных.

* **Атомарность**. Гарантирует, что транзакция будет полностью выполнена или потерпит неудачу, где транзакция
  представляет
  одну логическую операцию данных. Это означает, что при сбое одной части любой транзакции происходит сбой всей
  транзакции
  и состояние базы данных остается неизменным.

* **Согласованность**. Гарантирует, что данные должны соответствовать всем правилам валидации. Проще говоря, вы можете
  сказать, что ваша транзакция никогда не оставит вашу базу данных в недопустимом состоянии.

* **Изолированность**. Основной целью изолированности является контроль механизма параллельного изменения данных.

* **Долговечность**. Долговечность подразумевает, что если транзакция была подтверждена (COMMIT), произошедшие в рамках
  транзакции изменения сохранятся независимо от того, что может встать у них на пути (например, потеря питания, сбой или
  ошибки любого рода).

**17. Какие виды изолированности есть в SQL?**

Ответ:

* Read uncommitted (Чтение незафиксированных данных). Самый низкий уровень изолированности. На этом уровне транзакции
  изолированы только в такой степени, чтобы нельзя было читать физически поврежденные данные.
* Read committed (Чтение фиксированных данных). Принятый по умолчанию уровень для SQL Server. На этом уровне разрешается
  чтение только фиксированных данных. (Фиксированные данные – это данные, которые стали постоянной частью базы данных.)
* Repeatable read (Повторяемость чтения). Уровень, при котором чтение одной и той же строки или строк в транзакции дает
  одинаковый результат. (Пока транзакция не завершена, никакие другие транзакции не могут модифицировать эти данные.)
* Serializable (Упорядочиваемость). Самый высокий уровень изолированности; транзакции полностью изолируются друг от
  друга. На этом уровне результаты параллельного выполнения транзакций для базы данных совпадают с последовательным
  выполнением тех же транзакций (по очереди в каком-либо порядке).

**18. Что такое «триггеры» в SQL?**

Ответ:

Триггер в SQL — особый тип хранимых процедур, которые предназначены для автоматического выполнения в момент или после
изменения данных. Это позволяет вам выполнить пакет кода, когда вставка, обновление или любой другой запрос выполняется
к определенной таблице.

**19. Что такое подзапрос в SQL?**

Ответ:

**Подзапрос** — это запрос внутри другого запроса, в котором определен запрос для извлечения данных или информации из
базы
данных. В подзапросе внешний запрос называется основным запросом, тогда как внутренний запрос называется подзапросом.
Подзапросы всегда выполняются первыми, а результат подзапроса передается в основной запрос. Он может быть вложен в
SELECT, UPDATE или любой другой запрос. Подзапрос также может использовать любые операторы сравнения, такие как >, <
или =.

**20. Какие бывают типы подзапросов?**

Ответ:

Существует два типа подзапросов, а именно: коррелированные и некоррелированные.

* Коррелированный подзапрос: это запрос, который выбирает данные из таблицы со ссылкой на внешний запрос. Он не
  считается
  независимым запросом, поскольку ссылается на другую таблицу или столбец в таблице.
* Некоррелированный подзапрос: этот запрос является независимым запросом, в котором выходные данные подзапроса
  подставляются в основной запрос.

Объектно-ориентированное программирование
---

**1. Что такое ООП?**

Ответ:

ООП (объектно-ориентированное программирование) — это тип программирования, основанный на объектах, а не только на
функциях и процедурах. Отдельные объекты сгруппированы в классы. ООП внедряет в программирование реальные парадигмы,
такие как наследование, полиморфизм, инкапсуляция и т. д. ООП также позволяет связывать данные и код вместе.

**2. Зачем использовать ООП?**

Ответ:

* ООП обеспечивает ясность в программировании и, следовательно, простоту в решении сложных задач.
* Код может быть повторно использован посредством наследования, тем самым уменьшая избыточность
* Данные и код связаны вместе инкапсуляцией
* ООП позволяет скрывать данные, поэтому личные данные остаются конфиденциальными
* Проблемы могут быть разделены на мелкие части, что облегчает их решение
* Концепция полиморфизма придает программе гибкость, позволяя объектам иметь несколько форм.

**3. Назовите основные принципы ООП**

Ответ:

* Наследование
* Инкапсуляция
* Полиморфизм
* Абстракция

**4. Что такое наследование?**

Ответ:

**Наследование** — это особенность ООП, которая позволяет классам наследовать общие свойства от других классов.
Например,
если существует такой класс, как «транспортное средство», другие классы, такие как «автомобиль», «велосипед» и т. д.,
Могут наследовать общие свойства от класса транспортного средства. Это свойство помогает вам избавиться от избыточного
кода, тем самым уменьшая общий размер кода.

**5. Какие бывают виды наследования?**

Ответ:

* Единственное наследование
* Множественное наследование
* Многоуровневое наследование
* Иерархическое наследование
* Гибридное наследование

**6. Что такое полиморфизм?**

Ответ:

**Полиморфизм** — способность существовать в нескольких формах. Несколько определений могут быть объявлены для одного
интерфейса. Например, если у вас есть класс с именем «Автомобиль», у него может быть метод с именем speed, но вы не
можете определить его, потому что разные машины имеют разную скорость. Этот метод будет определен в подклассах с
разными определениями для разных транспортных средств.

**7. Что такое инкапсуляция?**

Ответ:

**Инкапсуляция** — это связывание данных и кода, который работает с этими данными. Например, класс. Инкапсуляция также
позволяет скрывать данные, так как данные, указанные в одном классе, скрыты от других классов.

**8. Что такое абстракция данных?**

Ответ:

Абстракция данных является очень важной особенностью ООП, которая позволяет отображать только важную информацию и
скрывать детали реализации. Например, когда вы едете на велосипеде, вы знаете, что если надавить на газ, скорость
увеличится, но вы не знаете, как это происходит на самом деле. Это абстракция данных, поскольку детали реализации скрыты
от гонщика.

**9. Как добиться абстракции данных?**

Ответ:

Абстрагирование данных может быть достигнуто через:

* Абстрактный класс
* Абстрактный метод

**10. В чем разница между классом и структурой**

Ответ:

* **Класс**: определенный пользователем проект, из которого создаются объекты. Он состоит из методов или набора
  инструкций,
  которые должны выполняться над объектами.
* **Структура**: пользовательский набор переменных разных типов данных.

**11. Можете ли вы вызвать метод базового класса, не создавая экземпляр?**

Ответ:

Да, вы можете вызывать базовый класс без его создания, если:

Это статический метод
Базовый класс наследуется некоторым другим подклассом

**12. Что такое дескрипторы данных?**

Ответ:

**Дескриптор** - такой атрибут объекта, поведение которого переопределяется специальными методами. Проще говоря, доступ
к
какому-то свойству экземпляра можно переопределить с учетом дополнительных проверок. Если делать эти верификации без
дескрипторов, то один и тот же код начнет повторяться.

Существует 4 метода протокола дескрипторов:

* \_\_get__() - получить значение свойства;
* \_\_set__() - задать значение;
* \_\_delete__() - удалить атрибут;
* \_\_set_name__() - присвоить имя свойству (появился в Питоне версии 3.6).

Best Practices
--------------

**1. Что такое YAGNI?**

Ответ:

You Aren’t Gonna Need It / Вам это не понадобится

Этот принцип прост и очевиден, но ему далеко не все следуют. Если пишете код, то будьте уверены, что он вам понадобится.
Не пишите код, если думаете, что он пригодится позже.

Этот принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять
лишние методы. Даже если раньше они были полезны – теперь они не нужны.

Может наступить день, когда они снова понадобятся – тогда вы сможете воспользоваться git-репозиторием, чтобы воскресить
их из мертвых.

**2. Что такое DRY?**

Ответ:

Don’t Repeat Yourself / Не повторяйтесь

Эта концепция была впервые сформулирована в книге Энди Ханта и Дэйва Томаса «Программист-прагматик: путь от подмастерья
к мастеру».

Идея вращается вокруг единого источника правды (single source of truth — SSOT). Что это вообще такое?

```
В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования
информационных моделей и схемы данных, которая подразумевает, что все фрагменты данных обрабатываются (или
редактируются) только в одном месте... SSOT предоставляют достоверные, актуальные и пригодные к использованию данные.

– Википедия
```

Использование SSOT позволит создать более прочную и понятную кодовую базу.

Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код
сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.

В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите
прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом
месте. Повторное использование кода – всегда разумное решение.

**3. Что такое KISS?**

Ответ:

Keep It Simple, Stupid / Будь проще

Этот принцип был разработан ВМС США в 1960 году. Этот принцип гласит, что простые системы будут работать лучше и
надежнее.

У этого принципа много общего с переизобретением колеса, которым занимались в 1970-х. Тогда он звучал как деловая и
рекламная метафора.

Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется.

Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода –
это прекрасно.

Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что
они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что
они подходят для работы.

**4. Что такое BDUF(Big Design Up Front)?**

Ответ:

Глобальное проектирование прежде всего

Этот подход к разработке программного обеспечения очень важен, и его часто игнорируют. Прежде чем переходить к
реализации, убедитесь, что все хорошо продумано.

```
Зачастую продумывание решений избавляло нас от проблем при разработке… Внесение изменений в спецификации занимало час
или два. Если бы мы вносили эти изменения в код, на это уходили бы недели. Я даже не могу выразить, насколько сильно я
верю в важность проектирования перед реализацией, хотя адепты экстремального программирования предали эту практику
анафеме. Я экономил время и делал свои продукты лучше, используя BDUF, и я горжусь этим фактом, чтобы там ни говорили
фанатики экстремального программирования. Они просто ошибаются, иначе сказать не могу.

— Джоел Спольски
```

Многие разработчики считают, что если они не пишут код, то они не добиваются прогресса. Это неверный подход. Составив
план, вы избавите себя от необходимости раз за разом начинать с нуля.

Иногда в недостатках и процессах разработки архитектуры должны быть замешаны и другие люди. Чем раньше вы все это
обсудите, тем лучше будет для всех.

Очень распространенный контраргумент заключается в том, что стоимость решения проблем зачастую ниже стоимости времени
планирования. Чем с меньшим количеством ошибок столкнется пользователь, тем лучше будет его опыт. У вас может не быть
другого шанса справиться с этими ошибками.

**5. Что такое SOLID?**

Ответ:

Это наиболее известный принцип разработки ПО.

**Solid** — это аббревиатура от:

**S) Single-responsibility principle /Принцип единственной ответственности**

Его важность невозможно переоценить. Каждый объект, класс и метод должны отвечать только за что-то одно. Если ваш
объект/класс/метод делает слишком много, вы получите спагетти-код.

Вот пример:

```javascript
const saveTodo = async () => {
    try {
        response = await saveTodoApi();
        showSuccessPop('Success');
        window.location.href = '/successPage';
    } catch (error) {
        showErrorPopup(`Error: ${error} `);
    }
}
```

Этот метод кажется безобидным, но на самом деле он делает слишком много:

1. Сохраняет объект
2. Обрабатывает уведомление в UI
3. Выполняет навигацию

Еще один побочный эффект такого кода – проблемы с тестированием. Запутанный функционал тестировать сложно.

**O) Open–closed principle / Принцип открытости-закрытости**

Программные объекты должны быть открыты для расширения, но закрыты для модификации. Речь о том, что нельзя
переопределять методы или классы, просто добавляя дополнительные функции по мере необходимости.

Хороший способ решения этой проблемы – использование наследования. В JavaScript эта проблема решается с помощью
композиции.

Простое правило: если вы изменяете сущность, чтобы сделать ее расширяемой, вы впервые нарушили этот принцип.

**L) Liskov substitution principle / Принцип подстановки Лисков**

Этот принцип гласит, что объекты старших классов должны быть заменимы объектами подклассов, и приложение при такой
замене должно работать так, как ожидается.

**I) Interface segregation principle / Принцип разделения интерфейсов**

Этот принцип был сформулирован Робертом Мартином, когда он консультировал Xerox, и он очевиден.

Объекты не должны зависеть от интерфейсов, которые они не используют

ПО должно разделяться на независимые части. Побочные эффекты необходимо сводить к минимуму, чтобы обеспечивать
независимость.

Убедитесь, что вы не заставляете объекты реализовывать методы, которые им никогда не понадобятся.

Вот пример:

```typescript
interface Animal {
    eat: () => void;
    walk: () => void;
    fly: () => void;
    swim: () => void;
}
```

Не все животные могут fly, walk или swim, поэтому эти методы не должны быть частью интерфейса или должны быть
необязательными.

**D) Dependency inversion principle / Принцип инверсии зависимостей**

Этот принцип невозможно переоценить. Мы должны полагаться на абстракции, а не на конкретные реализации. Компоненты ПО
должны иметь низкую связность и высокую согласованность.

Заботиться нужно не о том, как что-то устроено, а о том, как оно работает. Простой пример – использование дат в
JavaScript. Вы можете написать для них свой слой абстракции. Тогда если у вас сменится источник получения дат, вам нужно
будет внести изменения в одном месте, а не в тысяче.

Иногда добавление этого уровня абстракции требует усилий, но в конечном итоге они окупаются.

В качестве примера взгляните на date-io, в этой библиотеке создан тот уровень абстракции, который позволяет вам
использовать её с разными источниками дат.

**6. Avoid Premature Optimization**

Ответ:

Избегайте преждевременной оптимизации

Эта практика побуждает разработчиков оптимизировать код до того, как необходимость этой оптимизации будет доказана.
Думаю, что если вы следуете KISS или YAGNI, вы не попадетесь на этот крючок.

Поймите правильно, предвидеть, что произойдет что-то плохое – это хорошо. Но прежде чем вы погрузитесь в детали
реализации, убедитесь, что эти оптимизации действительно полезны.

Очень простой пример – масштабирование. Вы не станете покупать 40 серверов из предположения, что ваше новое приложение
станет очень популярным. Вы будете добавлять серверы по мере необходимости.

Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод
функций на рынок.

Многие считают преждевременную оптимизацию корнем всех зол.

**7. Бритва Оккама**

Ответ:

```
Бри́тва О́ккама (иногда ле́звие О́ккама) — методологический принцип, 
в кратком виде гласящий: «Не следует множить сущее без необходимости» 
(либо «Не следует привлекать новые сущности без крайней на то необходимости»).

— Википедия
```

Что это значит в мире программирования? Не создавайте ненужных сущностей без необходимости. Будьте прагматичны —
подумайте, нужны ли они, поскольку они могут в конечном итоге усложнить вашу кодовую базу.

**8. Паттерны проектирования.**

Ответ: тут вопросы по желанию
