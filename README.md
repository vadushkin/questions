# Вопросы на тему программирования

Софт скилы
----------

1. Скажите мне, как бы вы преодолели ситуацию, когда команда плохо работает, потому что члены не ладят.
2. Что для вас значит командный дух и как бы вы его построили?
3. Как бы вы справились с товарищем по команде, который не выполнял свою долю работы?
4. Вы знаете, что ваш менеджер на 100% неправ в чем-то. Что вы сделаете?
5. Как вы относитесь к делегированию обязанностей в команде?
6. С каким самым трудным изменением вы столкнулись в своей карьере?
7. Как вы меняете свое расписание, если происходит что-то незапланированное?
8. Приведите пример, когда вы успешно решили проблему.
9. Приведите пример, когда вам приходилось проявлять творческий подход или нестандартность в решении проблемы.
10. Как вы сохраняете мотивацию, работая в одиночку над проектом?
11. Чего вы надеетесь достичь в течение первых шести месяцев работы в нашей компании?
12. Вам нравится ответственность за принятие решений или вы бы предпочли оставить это кому-то другому?
13. Что заставит вас бросить работу в первый месяц?

Python
------
**1. В чем разница между списком и кортежем?**

Ответ:
<ul>
    <li>Список можно изменить после создания.</li>
    <li>Кортеж нельзя изменить после создания.</li>
    <li>Кортеж хешируется, значит может использоваться как ключ в словаре</li>
    <li>Список не хешируется, значит не может быть использован как ключ в словаре</li>
</ul>

**2. Как выполняется интерполяция строк?**

Ответ:

```python
name = 'Chris'

# 1. f strings
print(f'Hello {name}')

# 2. % operator
print('Hey %s %s' % (name, name))

# 3. format
print(
 "My name is {}".format((name))
)
```

**3. В чем разница между "is" и "==" ?**

Ответ:

is проверяет идентичность, а == проверяет равенство.

```python
a = [1,2,3]
b = a
c = [1,2,3]
...
print(a == b)
print(a == c)
#=> True
#=> True
...
print(a is b)
print(a is c)
#=> True
#=> False
...
print(id(a))
print(id(b))
print(id(c))
#=> 4369567560
#=> 4369567560
#=> 4369567624
```

**4. Что такое декоратор?**

Ответ:

Декораторы – это обертка вокруг функций (или классов) в Python, которая меняет способ работы этой функции. Декоратор
абстрагирует свой собственный функционал.

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        print("Hello, World!")
        func(*args, **kwargs)
    return wrapper

@decorator
def main():
    print("I'm here!")


main()
...
#=> Hello, World!
#=> I'm here!
```

**5. Объясните, как работает функция reduce**

Ответ:

reduce принимает функцию и последовательность — и проходит по этой последовательности. На каждой итерации в функцию
передаются как текущий элемент, так и выходные данные предыдущего элемента. В конце концов, возвращается одно значение:

```python
from functools import reduce


def add_three(x,y):
    return x + y
    
    
li = [1,2,3,5]

print(reduce(add_three, li))
...
#=> 11
```

**6. Объясните, как работает функция filter**

Ответ:

Функция делает буквально то, о чем говорит ее название: она фильтрует элементы в последовательности.

Каждый элемент передается функции, которая включает его в последовательность, если по условию получает True, и
отбрасывает в случае False:

```python 
def add_three(x):
    if x % 2 == 0:
        return True        
    return False

li = [1,2,3,4,5,6,7,8]

print([i for i in filter(add_three, li)])
...
#=> [2, 4, 6, 8]
```

**7. Переменные в Python передаются по ссылке или по значению?**

Ответ:

В Python аргументы передаются по ссылке, т. е. передается ссылка на реальный объект.

Но есть два вида передачи объекта в
аргументах.

* По значению: Передается копия реального объекта. Изменение значения копии объекта не приведет к изменению
  значения исходного объекта.
* По ссылке: Передается ссылка на реальный объект.

**8. В чем разница между глубокой и мелкой копиями?**

Ответ:

* Глубокие копирования хранят копию значений объекта перечисляется, тогда как мелкая копия историй ссылка на исходный
  адрес памяти
* Глубокая копия не отражает изменений, внесенных в новый / скопированный объект в исходном объекте; тогда как
  неглубокая копия делает

Полное копирование: ```copy.deepcopy```

```python
import copy 

result_A = [[90, 85, 82], [72, 88, 90]]
result_B = copy.deepcopy(result_A)

result_B[0][0] = 30 

print(result_A) 
print(result_B) 
...
[[90, 85, 82], [72, 88, 90]] 
[[30, 85, 82], [72, 88, 90]] 
```

Поверхностное копирование: ```copy.copy```

```python
import copy 
 
result_A = [[90, 85, 82], [72, 88, 90]]
result_B = copy.copy(result_A) 
 
result_B[0][0] = 30 
 
print(result_A) 
print(result_B)
... 
[[30, 85, 82], [72, 88, 90]] 
[[30, 85, 82], [72, 88, 90]] 
```

**9. В чем разница между модулем и пакетом?**

Ответ:

Модуль — это файл или набор файлов, которые импортируются вместе:

```python
import sklearn
```

Пакет — это каталог с модулями:

```python
from sklearn import cross_validation
```

Таким образом, пакеты — это модули, но не все модули являются пакетами.

Django
------

**1. Что такое Django?**

Ответ:

Django - это платформа веб-разработки с открытым исходным кодом, основанная на языке Python, позволяющая разработчикам
Python создавать веб-сайты, управляемые базами данных. Использует шаблон проектирования MVC.
Он был представлен в 2003 году в журнале Lawrence Journal - всемирной газете.

Этот популярный фреймворк поддерживается некоммерческой организацией Django Software Foundation (DSF). Позже, в 2005
году, Django стал общедоступным под лицензией BSD с 3 пунктами.

**2. В чем преимущества Django?**

Ответ:

Большинство разработчиков предпочитают Django из-за его доминирования на рынке, поскольку он демонстрирует высокие
вычислительные и статистические возможности. Ниже приведены некоторые из преимуществ Django:

* Django следует принципу Python "батарейки в комплекте". Python обычно называют "включенными батареями", потому что он
  имеет унифицированную стандартную библиотеку, помогающую разработчикам использовать готовые пакеты для добавления
  функций в веб-проект.
* Большинство пакетов в стандартной библиотеке Python имеют открытый исходный код. С помощью этих пакетов вы даже можете
  реализовать аутентификацию, взаимодействие с администратором, управление сеансами и другие расширенные функциональные
  возможности.
* Python и Django являются основными технологиями в ИТ-гигантах, Интернете вещей (IoT) и компаниях с "голубыми фишками".
  Поэтому изучение этого поможет вам построить прибыльную карьеру.
* Безопасность - еще одно преимущество использования платформы Django. Приложения, разработанные на Django, защищены от
  SQL-инъекций, взлома кликов, атак XSS и CSRF и т. Д.
* Встроенный язык шаблонов Django способствует процессу создания приложений.
* Django позволяет разработчикам создавать приложения и настраивать фреймворки на ходу. Кроме того, он предлагает
  поддержку внешних библиотек и пакетов. Django фокусируется на явном программировании, позволяя разработчикам создавать
  приложения, требующие частых изменений.
* Это помогает ускорить разработку и, таким образом, используется большинством компаний. Если конфигурация правильная,
  вы можете использовать Django для оптимизации веб-приложений.
* В Django есть REST framework, библиотека python, которая помогает разрабатывать API для многих приложений. Используя
  эти API, вы можете добавлять расширенные функциональные возможности в свои приложения.
* Django поставляется с возможностями ML и библиотеками, такими как PyTorch, NumPy и др.

**3. Каковы недостатки Django?**

Ответ:

Несмотря на множество преимуществ, разработчикам по-прежнему сложно осуществить переход. Ниже приведены некоторые
недостатки использования фреймворка Django:

* Позволяет создавать только одно уровневые приложения.
* Не подходит для небольших приложений.
* Требует большего понимания структуры.

**4. Опишите архитектуру Django.**

Ответ:

Django следует архитектуре Model-View-Template (MVT), основанной на популярном архитектурном шаблоне
Model-View-Controller (MVC), которому следуют популярные веб-фреймворки, такие как Ruby on Rails, Laravel и др.

Архитектура Django Model-View-Template делит все приложение на три основных логических компонента:

* Модель
* Вид
* Шаблон

Все эти три компонента отвечают за обработку различных аспектов веб-приложения.

**Модель**: модели обрабатывают схему базы данных для веб-приложений. Он поддерживает и представляет полные данные
приложения в базе данных. Реляционной базой данных по умолчанию, используемой моделью, является SQLite, которая обычно
используется в разработке, но в производстве мы можем использовать MySQL и Postgres.

**Просмотр**: компонент просмотра управляет всей логикой приложения, которую мы хотим отобразить в браузере
пользователя. В
Django представление служит связующим звеном между моделями и шаблонами. В представлениях мы можем извлекать данные из
моделей и отображать их в шаблоне.

**Шаблон**: Компонент шаблона представляет собой набор статических частей приложения, таких как HTML, CSS, JavaScript и
файлы изображений. Представление использует шаблон в качестве основы, на которой должны быть представлены данные, потому
что в конце веб-приложение использует статические файлы для представления содержимого в браузере пользователя.

**5. Что происходит, когда веб-сайт Django получает запрос?**

Ответ:

Кратко

Всякий раз, когда пользователь вводит URL-адрес в браузере, сервер Django получает запрос. Сервер ищет URL-адрес в своей
URL-конфигурации. Если сервер найдет там совпадение, он вернет соответствующую функцию просмотра.

Затем для получения данных делается запрос к модели приложения. Если нужно передать какие-либо данные, передайте их в
соответствующий шаблон. После этого шаблон отображается в браузере. Если процесс не работает должным образом,
пользователь получит страницу с ошибкой “404”.

**6. Объясните ORM на Django.**

Ответ:

ORM расшифровывается как Object-relational mapper, специальный функциональный инструмент Django. Этот инструмент
помогает разработчикам взаимодействовать с базой данных более похожим на Python способом. Он действует как абстракция
между моделями и базой данных, где хранятся основные данные.

Используя ORM, вы можете извлекать, сохранять и удалять данные из базы данных без необходимости писать для них
какой-либо SQL-код. Этот инструмент поможет устранить многие лазейки, поскольку он позволяет вам сохранять контроль над
вашим кодом и разработан на Python.

Не имеет значения, является ли база данных SQLite, MySQL, Postgre или Oracle, ORM гарантирует, что разработчик пишет
один и тот же код для всех баз данных.

Django использует ORM, известный как Django ORM, он использует классы, унаследованные от моделей.Modle, для создания
таблиц в любой базе данных.

Единственное, что нам нужно изменить, это настройки базы данных в setting.py досье.

**7. Что такое функция django.shortcuts.render?**

Ответ:

Когда функция просмотра возвращает веб-страницу как HttpResponse вместо простой строки, используйте функцию render() .
Эта функция позволит разработчикам передавать словарь данных с помощью шаблона. Затем эта функция будет использовать
механизм создания шаблонов для объединения шаблона со словарем данных.

После этого эта функция вернет HttpResponse с отображаемым текстом, который возвращается моделями. Таким образом, эта
функция сэкономит много времени разработчикам и позволит им использовать разные механизмы создания шаблонов.

**8. Что такое Middleware?**

Ответ:

**Middleware** - это система хуков для обработки запросов/ответов в Django. Это легкая, низкоуровневая система
«плагинов»
для глобального изменения входных или выходных данных Django. Каждый компонент промежуточного ПО отвечает за выполнение
определенной функции. Например, Django включает компонент промежуточного ПО, AuthenticationMiddleware, который связывает
пользователей с запросами с помощью сессий.

**9. Что такое сигналы в Django?**

Ответ:

**Сигналы** - это фрагменты кода, которые содержат информацию о том, что происходит. Вы можете использовать диспетчера
для
отправки сигналов и прослушивания этих сигналов.

Сигналы становятся очень полезными, когда мы хотим что-то сделать с данными, до или после того, как произойдет
определенное событие.

Вот список событий, на которых мы можем использовать сигналы Django:

* функция pre_save() срабатывает перед функцией save().
* post_save() запускается после сохранения ().
* запуск функции pre_delete() перед удалением().
* post_delete() запускается после delete().
* m2m_changed() срабатывает при изменении поля ManyToMany.
* request_started() запускается, когда django запускает HTTP-запрос.
* request_finished() запускается, когда django завершает HTTP-запрос.

Пример

```python
from .models import Blog

from django.core.mail import send_mail
from django.db.models.signals import post_save


@receiver(post_save, sender=Blog)
def create_profile(sender, instance, created, **kwargs):
    if created:
        blog_title = instance.title
        send_mail("Subject", "Message", "from_email", ['toemail@.com'])
```

**10. Что такое микширование в Django?**

Ответ:

Mixin - это тип множественного наследования, который объединяет поведение и атрибуты более чем одного родительского
класса. Это обеспечивает отличный способ повторного использования кода из нескольких классов.

Например, общие представления на основе классов имеют миксин, называемый TemplateResponseMixin. Этот микс используется
для определения метода render_to_response(). Когда вы объединяете его с классом, присутствующим в представлении, в
результате получается класс TemplateView.

Единственным недостатком mixin является то, что становится трудно анализировать, что делает дочерний класс и какие
методы переопределять, если его код разбросан между несколькими классами.

**11. Каковы стратегии кэширования в Django?**

Ответ:

Кэширование подразумевает сохранение выходных данных вычислений, чтобы избежать повторного выполнения одних и тех
же вычислений. Django поставляется с надежной системой кэширования, помогающей создавать динамические страницы. Таким
образом, отпадает необходимость многократной оценки страниц для каждого запроса. В следующей таблице приведены некоторые
из важных стратегий кэширования:

<table>
  <tr>
    <th>Стратегии</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>Memcached</td>
    <td>Это кэш-сервер на основе памяти.</td>
  </tr>
  <tr>
    <td>Filesystem caching</td>
    <td>Эта стратегия кэширования помогает кэшировать значения, хранящиеся в виде отдельных файлов в сериализованном порядке.</td>
  </tr>  
  <tr>
    <td>Local-memory caching</td>
    <td>Это кэш по умолчанию, и он используется, если вы не указали какой-либо другой. Это кэш для каждого процесса и потокобезопасный.</td>
  </tr>
  <tr>
    <td>Database caching</td>
    <td>В базе данных хранятся данные кэша.</td>
  </tr>
</table>

**12. Что такое manage.py файл в Django?**

Ответ:

Всякий раз, когда вы создаете проект, manage.py файл создается автоматически. Это утилита командной строки, помогающая
вам взаимодействовать с вашим проектом Django. Он выполняет ту же работу, что и Django-admin, и устанавливает переменную
среды DJANGO_SETTINGS_MODULE так, чтобы она указывала на настройки вашего проекта. Лучше, если вы используете manage.py
вместо Django-admin, если вы работаете над одним проектом.

**13. Каков цикл ответов в Django?**

Ответ:

Всякий раз, когда пользователь запрашивает веб-страницу, Django создает объект HttpRequest, содержащий важные метаданные
об этом запросе. После этого Django загрузит конкретное представление, передав HttpRequest в качестве первого аргумента
функции просмотра. Затем каждое представление возвращает объект HttpResponse.

![Example](https://lh6.googleusercontent.com/tERwVkYqzL5WbQAEZODCywIeT4JjoidLu7hjrZj5NG_R-k6mu3On7tEl3elrbS7K4EWw-uSUvOj1rCQ_rthHfMBGATIBUHElka9t7q8YudMuj1vT7Myet620XZFVtAGpUfehYby8)

Ниже приведены шаги, которые выполняются при получении запроса Django:

* Во-первых, settings.py загружается файл, содержащий различные классы промежуточного программного обеспечения
* Все классы промежуточного программного обеспечения выполняются в том же порядке, в котором они упоминаются
* Теперь запрос будет перемещен на URL-маршрутизатор. URL-маршрутизатор получает URL-путь из запроса, а затем пытается
  сопоставить с заданными URL-путями в urls.py .
* После сопоставления он вызывает эквивалентную функцию просмотра, откуда генерируется соответствующий ответ.
* Теперь ответ проходит через промежуточное программное обеспечение response и отправляется обратно клиенту / браузеру

**14. В чем разница между select_related и prefetch_related?**

<table class="c24">
  <tbody>
    <tr>
      <td>
        <p>select_related()</p>
      </td>
      <td>
      <p>prefetch_related()</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>Функция select_related() выполняет поиск набора запросов, она добавляет дополнительные данные из ForeignKey в QuerySet.</p>
      </td>
      <td>
        <p>Функция prefetch_related() - это еще один поиск для набора запросов, он добавляет дополнительные данные из ForeignKey, OneToOne и в OneToOne в набор запросов возврата.</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>Это уменьшает фоновый SQL-запрос с использованием операторов JOIN.</p>
      </td>
      <td>
        <p>Он использует SQL joins и команду SELECT, чтобы уменьшить сложный набор запросов.</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>Это работает, когда мы выбираем отдельные объекты.</p>
      </td>
      <td>
        <p>Он используется для выбора набора из нескольких объектов.</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>Пример</p>
        <p>&nbsp;</p>
        <pre>queryset = Blog.objects.select_related(<span>'Author'</span>).all()</pre>
        <p>&nbsp;</p>
        <p>&nbsp;</p>
      </td>
      <td>
        <p>Пример</p>
        <p>&nbsp;</p>
        <pre>queryset = Blog.objects.prefetch_related(<span>'Categories'</span>).all()</pre>
        <p>&nbsp;</p>
        <p>&nbsp;</p>
      </td>
    </tr>
  </tbody>
</table>

Пример:

```python
from django.db import models


class Country(models.Model):
   country_name = models.CharField(max_length=5)
   
   
class State(models.Model):
   state_name = models.CharField(max_length=5)
   country = model.ForeignKey(Country)
   
   
>> states = State.objects.select_related('country').all()
>> for state in states:
...   print(state.state_name)  

#=> SELECT state_id, state_name, country_name FROM State INNER JOIN Country ON (State.country_id = Country.id)

>> country = Country.objects.prefetch_related('state').get(id=1)
>> for state in country.state.all():
...   print(state.state_name)

#=> SELECT id, country_name FROM country WHERE id=1;
#=> SELECT state_id, state_name WHERE State WHERE country_id IN (1);
```

**15. Что такое FBV и CBV?**

Ответ:

* FBV（function base views）- Это использование функции в представлении для обработки запроса.
* CBV（class base views）- Это использование класса в представлении для обработки запроса.

**16. В чём разница между файлом cookie и сеансом**

Ответ:

* **Cookie** - это пара "ключ-значение", хранящаяся в браузере, которая может использоваться для аутентификации
  пользователя.
* **Session** - сохранить информацию о сеансе пользователя на сервере, значение ключа - это случайно сгенерированная
  строка, а значение value - это содержимое сеанса.
  использует файлы cookie для сохранения случайной строки каждого пользователя в браузере пользователя.

**17. Где хранятся сессии в Django?**

Ответ:

Сессия в Django по умолчанию сохраняется в базе данных: таблица django_session

**18. Что такое WSGI?**

Ответ:

WSGI - это метод обработки, предписанный Python при обработке HTTP-запросов. Если приходит HTTP-запрос, есть
соответствующая функция обработки для обработки и возврата результата. WSGI указывает, как выглядят параметры этой
функции обработки и как выглядит результат ее возврата? Что касается имени и логики обработки функции обработки, это не
имеет значения. Проще говоря, WSGI определяет формат ввода и вывода функции обработки.

**19. Что такое csrf token?**

Ответ:

Тег {% csrf_token %} содержит встроенную в Django функцию защиты от подделки межсайтовых запросов (CSRF) (документация
Django). Обычно этот тег добавляется в каждый элемент, для которого используются методы запросов POST, PUT или delete,
такой как форма. С помощью функции отображения в шаблон (render) затем вставляются необходимые средства защиты.

**20. Что вам больше всего нравится в Django?**

Ответ: по желанию

**21. Что вам больше всего не навится в Django?**

Ответ: по желанию
