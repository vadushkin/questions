# Вопросы на тему программирования

Софт скилы
----------

**Вводные**:

1. Скажите мне немного о себе.
2. Какие у тебя интересы?
3. Как вы узнали о нашей компании?
4. Что дает вам право на эту роль?
5. Каковы ваши самые сильные технические навыки?
6. Как вы относитесь к профессиональному развитию?
7. Что является одним из ваших слабых навыков? Какие шаги вы предпринимаете для улучшения?
8. Каковы ваши цели в программной инженерии?
9. Что вы надеетесь сделать для нашей компании в течение первых 90 дней?
10. Что вам нравится в программировании больше всего?

**Ситуации**:

1. Скажите мне, как бы вы преодолели ситуацию, когда команда плохо работает, потому что члены не ладят.
2. Что для вас значит командный дух и как бы вы его построили?
3. Как бы вы справились с товарищем по команде, который не выполнял свою долю работы?
4. Вы знаете, что ваш менеджер на 100% неправ в чем-то. Что вы сделаете?
5. Как вы относитесь к делегированию обязанностей в команде?
6. С каким самым трудным изменением вы столкнулись в своей карьере?
7. Как вы меняете свое расписание, если происходит что-то незапланированное?
8. Приведите пример, когда вы успешно решили проблему.
9. Приведите пример, когда вам приходилось проявлять творческий подход или нестандартность в решении проблемы.
10. Как вы сохраняете мотивацию, работая в одиночку над проектом?
11. Чего вы надеетесь достичь в течение первых шести месяцев работы в нашей компании?
12. Вам нравится ответственность за принятие решений или вы бы предпочли оставить это кому-то другому?
13. Что заставит вас бросить работу в первый месяц?

Python
------
**1. В чем разница между списком и кортежем?**

Ответ:
<ul>
    <li>Список можно изменить после создания.</li>
    <li>Кортеж нельзя изменить после создания.</li>
    <li>Кортеж хешируется, значит может использоваться как ключ в словаре</li>
    <li>Список не хешируется, значит не может быть использован как ключ в словаре</li>
</ul>

**2. Как выполняется интерполяция строк?**

Ответ:

```python
name = 'Chris'

# 1. f strings
print(f'Hello {name}')

# 2. % operator
print('Hey %s %s' % (name, name))

# 3. format
print(
 "My name is {}".format((name))
)
```

**3. В чем разница между "is" и "==" ?**

Ответ:

is проверяет идентичность, а == проверяет равенство.

```python
a = [1,2,3]
b = a
c = [1,2,3]
...
print(a == b)
print(a == c)
#=> True
#=> True
...
print(a is b)
print(a is c)
#=> True
#=> False
...
print(id(a))
print(id(b))
print(id(c))
#=> 4369567560
#=> 4369567560
#=> 4369567624
```

**4. Что такое декоратор?**

Ответ:

Декораторы – это обертка вокруг функций (или классов) в Python, которая меняет способ работы этой функции. Декоратор
абстрагирует свой собственный функционал.

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        print("Hello, World!")
        func(*args, **kwargs)
    return wrapper

@decorator
def main():
    print("I'm here!")


main()
...
#=> Hello, World!
#=> I'm here!
```

**5. Объясните, как работает функция reduce**

Ответ:

reduce принимает функцию и последовательность — и проходит по этой последовательности. На каждой итерации в функцию
передаются как текущий элемент, так и выходные данные предыдущего элемента. В конце концов, возвращается одно значение:

```python
from functools import reduce


def add_three(x,y):
    return x + y
    
    
li = [1,2,3,5]

print(reduce(add_three, li))
...
#=> 11
```

**6. Объясните, как работает функция filter**

Ответ:

Функция делает буквально то, о чем говорит ее название: она фильтрует элементы в последовательности.

Каждый элемент передается функции, которая включает его в последовательность, если по условию получает True, и
отбрасывает в случае False:

```python 
def add_three(x):
    if x % 2 == 0:
        return True        
    return False

li = [1,2,3,4,5,6,7,8]

print([i for i in filter(add_three, li)])
...
#=> [2, 4, 6, 8]
```

**7. Переменные в Python передаются по ссылке или по значению?**

Ответ:

В Python аргументы передаются по ссылке, т. е. передается ссылка на реальный объект.

Но есть два вида передачи объекта в
аргументах.

* По значению: Передается копия реального объекта. Изменение значения копии объекта не приведет к изменению
  значения исходного объекта.
* По ссылке: Передается ссылка на реальный объект.

**8. В чем разница между глубокой и мелкой копиями?**

Ответ:

* Глубокие копирования хранят копию значений объекта перечисляется, тогда как мелкая копия историй ссылка на исходный
  адрес памяти
* Глубокая копия не отражает изменений, внесенных в новый / скопированный объект в исходном объекте; тогда как
  неглубокая копия делает

Полное копирование: ```copy.deepcopy```

```python
import copy 

result_A = [[90, 85, 82], [72, 88, 90]]
result_B = copy.deepcopy(result_A)

result_B[0][0] = 30 

print(result_A) 
print(result_B) 
...
[[90, 85, 82], [72, 88, 90]] 
[[30, 85, 82], [72, 88, 90]] 
```

Поверхностное копирование: ```copy.copy```

```python
import copy 
 
result_A = [[90, 85, 82], [72, 88, 90]]
result_B = copy.copy(result_A) 
 
result_B[0][0] = 30 
 
print(result_A) 
print(result_B)
... 
[[30, 85, 82], [72, 88, 90]] 
[[30, 85, 82], [72, 88, 90]] 
```

**9. В чем разница между модулем и пакетом?**

Ответ:

Модуль — это файл или набор файлов, которые импортируются вместе:

```python
import sklearn
```

Пакет — это каталог с модулями:

```python
from sklearn import cross_validation
```

Таким образом, пакеты — это модули, но не все модули являются пакетами.

Django
------

**1. Что такое Django?**

Ответ:

Django - это платформа веб-разработки с открытым исходным кодом, основанная на языке Python, позволяющая разработчикам
Python создавать веб-сайты, управляемые базами данных. Использует шаблон проектирования MVC.
Он был представлен в 2003 году в журнале Lawrence Journal - всемирной газете.

Этот популярный фреймворк поддерживается некоммерческой организацией Django Software Foundation (DSF). Позже, в 2005
году, Django стал общедоступным под лицензией BSD с 3 пунктами.

**2. В чем преимущества Django?**

Ответ:

Большинство разработчиков предпочитают Django из-за его доминирования на рынке, поскольку он демонстрирует высокие
вычислительные и статистические возможности. Ниже приведены некоторые из преимуществ Django:

* Django следует принципу Python "батарейки в комплекте". Python обычно называют "включенными батареями", потому что он
  имеет унифицированную стандартную библиотеку, помогающую разработчикам использовать готовые пакеты для добавления
  функций в веб-проект.
* Большинство пакетов в стандартной библиотеке Python имеют открытый исходный код. С помощью этих пакетов вы даже можете
  реализовать аутентификацию, взаимодействие с администратором, управление сеансами и другие расширенные функциональные
  возможности.
* Python и Django являются основными технологиями в ИТ-гигантах, Интернете вещей (IoT) и компаниях с "голубыми фишками".
  Поэтому изучение этого поможет вам построить прибыльную карьеру.
* Безопасность - еще одно преимущество использования платформы Django. Приложения, разработанные на Django, защищены от
  SQL-инъекций, взлома кликов, атак XSS и CSRF и т. Д.
* Встроенный язык шаблонов Django способствует процессу создания приложений.
* Django позволяет разработчикам создавать приложения и настраивать фреймворки на ходу. Кроме того, он предлагает
  поддержку внешних библиотек и пакетов. Django фокусируется на явном программировании, позволяя разработчикам создавать
  приложения, требующие частых изменений.
* Это помогает ускорить разработку и, таким образом, используется большинством компаний. Если конфигурация правильная,
  вы можете использовать Django для оптимизации веб-приложений.
* В Django есть REST framework, библиотека python, которая помогает разрабатывать API для многих приложений. Используя
  эти API, вы можете добавлять расширенные функциональные возможности в свои приложения.
* Django поставляется с возможностями ML и библиотеками, такими как PyTorch, NumPy и др.

**3. Каковы недостатки Django?**

Ответ:

Несмотря на множество преимуществ, разработчикам по-прежнему сложно осуществить переход. Ниже приведены некоторые
недостатки использования фреймворка Django:

* Позволяет создавать только одно уровневые приложения.
* Не подходит для небольших приложений.
* Требует большего понимания структуры.

**4. Опишите архитектуру Django.**

Ответ:

Django следует архитектуре Model-View-Template (MVT), основанной на популярном архитектурном шаблоне
Model-View-Controller (MVC), которому следуют популярные веб-фреймворки, такие как Ruby on Rails, Laravel и др.

Архитектура Django Model-View-Template делит все приложение на три основных логических компонента:

* Модель
* Вид
* Шаблон

Все эти три компонента отвечают за обработку различных аспектов веб-приложения.

**Модель**: модели обрабатывают схему базы данных для веб-приложений. Он поддерживает и представляет полные данные
приложения в базе данных. Реляционной базой данных по умолчанию, используемой моделью, является SQLite, которая обычно
используется в разработке, но в производстве мы можем использовать MySQL и Postgres.

**Просмотр**: компонент просмотра управляет всей логикой приложения, которую мы хотим отобразить в браузере
пользователя. В
Django представление служит связующим звеном между моделями и шаблонами. В представлениях мы можем извлекать данные из
моделей и отображать их в шаблоне.

**Шаблон**: Компонент шаблона представляет собой набор статических частей приложения, таких как HTML, CSS, JavaScript и
файлы изображений. Представление использует шаблон в качестве основы, на которой должны быть представлены данные, потому
что в конце веб-приложение использует статические файлы для представления содержимого в браузере пользователя.

**5. Что происходит, когда веб-сайт Django получает запрос?**

Ответ:

Кратко

Всякий раз, когда пользователь вводит URL-адрес в браузере, сервер Django получает запрос. Сервер ищет URL-адрес в своей
URL-конфигурации. Если сервер найдет там совпадение, он вернет соответствующую функцию просмотра.

Затем для получения данных делается запрос к модели приложения. Если нужно передать какие-либо данные, передайте их в
соответствующий шаблон. После этого шаблон отображается в браузере. Если процесс не работает должным образом,
пользователь получит страницу с ошибкой “404”.

**6. Объясните ORM на Django.**

Ответ:

ORM расшифровывается как Object-relational mapping, специальный функциональный инструмент Django. Этот инструмент
помогает разработчикам взаимодействовать с базой данных более похожим на Python способом. Он действует как абстракция
между моделями и базой данных, где хранятся основные данные.

Используя ORM, вы можете извлекать, сохранять и удалять данные из базы данных без необходимости писать для них
какой-либо SQL-код. Этот инструмент поможет устранить многие лазейки, поскольку он позволяет вам сохранять контроль над
вашим кодом и разработан на Python.

Не имеет значения, является ли база данных SQLite, MySQL, Postgre или Oracle, ORM гарантирует, что разработчик пишет
один и тот же код для всех баз данных.

Django использует ORM, известный как Django ORM, он использует классы, унаследованные от моделей.Modle, для создания
таблиц в любой базе данных.

Единственное, что нам нужно изменить, это настройки базы данных в setting.py досье.

**7. Что такое функция django.shortcuts.render?**

Ответ:

Когда функция просмотра возвращает веб-страницу как HttpResponse вместо простой строки, используйте функцию render() .
Эта функция позволит разработчикам передавать словарь данных с помощью шаблона. Затем эта функция будет использовать
механизм создания шаблонов для объединения шаблона со словарем данных.

После этого эта функция вернет HttpResponse с отображаемым текстом, который возвращается моделями. Таким образом, эта
функция сэкономит много времени разработчикам и позволит им использовать разные механизмы создания шаблонов.

**8. Что такое Middleware?**

Ответ:

**Middleware** - это система хуков для обработки запросов/ответов в Django. Это легкая, низкоуровневая система
«плагинов»
для глобального изменения входных или выходных данных Django. Каждый компонент промежуточного ПО отвечает за выполнение
определенной функции. Например, Django включает компонент промежуточного ПО, AuthenticationMiddleware, который связывает
пользователей с запросами с помощью сессий.

**9. Что такое сигналы в Django?**

Ответ:

**Сигналы** - это фрагменты кода, которые содержат информацию о том, что происходит. Вы можете использовать диспетчера
для
отправки сигналов и прослушивания этих сигналов.

Сигналы становятся очень полезными, когда мы хотим что-то сделать с данными, до или после того, как произойдет
определенное событие.

Вот список событий, на которых мы можем использовать сигналы Django:

* функция pre_save() срабатывает перед функцией save().
* post_save() запускается после сохранения ().
* запуск функции pre_delete() перед удалением().
* post_delete() запускается после delete().
* m2m_changed() срабатывает при изменении поля ManyToMany.
* request_started() запускается, когда django запускает HTTP-запрос.
* request_finished() запускается, когда django завершает HTTP-запрос.

Пример

```python
from .models import Blog

from django.core.mail import send_mail
from django.db.models.signals import post_save


@receiver(post_save, sender=Blog)
def create_profile(sender, instance, created, **kwargs):
    if created:
        blog_title = instance.title
        send_mail("Subject", "Message", "from_email", ['toemail@.com'])
```

**10. Что такое микширование в Django?**

Ответ:

Mixin - это тип множественного наследования, который объединяет поведение и атрибуты более чем одного родительского
класса. Это обеспечивает отличный способ повторного использования кода из нескольких классов.

Например, общие представления на основе классов имеют миксин, называемый TemplateResponseMixin. Этот микс используется
для определения метода render_to_response(). Когда вы объединяете его с классом, присутствующим в представлении, в
результате получается класс TemplateView.

Единственным недостатком mixin является то, что становится трудно анализировать, что делает дочерний класс и какие
методы переопределять, если его код разбросан между несколькими классами.

**11. Каковы стратегии кэширования в Django?**

Ответ:

Кэширование подразумевает сохранение выходных данных вычислений, чтобы избежать повторного выполнения одних и тех
же вычислений. Django поставляется с надежной системой кэширования, помогающей создавать динамические страницы. Таким
образом, отпадает необходимость многократной оценки страниц для каждого запроса. В следующей таблице приведены некоторые
из важных стратегий кэширования:

<table>
  <tr>
    <th>Стратегии</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>Memcached</td>
    <td>Это кэш-сервер на основе памяти.</td>
  </tr>
  <tr>
    <td>Filesystem caching</td>
    <td>Эта стратегия кэширования помогает кэшировать значения, хранящиеся в виде отдельных файлов в сериализованном порядке.</td>
  </tr>  
  <tr>
    <td>Local-memory caching</td>
    <td>Это кэш по умолчанию, и он используется, если вы не указали какой-либо другой. Это кэш для каждого процесса и потокобезопасный.</td>
  </tr>
  <tr>
    <td>Database caching</td>
    <td>В базе данных хранятся данные кэша.</td>
  </tr>
</table>

**12. Что такое manage.py файл в Django?**

Ответ:

Всякий раз, когда вы создаете проект, manage.py файл создается автоматически. Это утилита командной строки, помогающая
вам взаимодействовать с вашим проектом Django. Он выполняет ту же работу, что и Django-admin, и устанавливает переменную
среды DJANGO_SETTINGS_MODULE так, чтобы она указывала на настройки вашего проекта. Лучше, если вы используете manage.py
вместо Django-admin, если вы работаете над одним проектом.

**13. Каков цикл ответов в Django?**

Ответ:

Всякий раз, когда пользователь запрашивает веб-страницу, Django создает объект HttpRequest, содержащий важные метаданные
об этом запросе. После этого Django загрузит конкретное представление, передав HttpRequest в качестве первого аргумента
функции просмотра. Затем каждое представление возвращает объект HttpResponse.

![Example](https://lh6.googleusercontent.com/tERwVkYqzL5WbQAEZODCywIeT4JjoidLu7hjrZj5NG_R-k6mu3On7tEl3elrbS7K4EWw-uSUvOj1rCQ_rthHfMBGATIBUHElka9t7q8YudMuj1vT7Myet620XZFVtAGpUfehYby8)

Ниже приведены шаги, которые выполняются при получении запроса Django:

* Во-первых, settings.py загружается файл, содержащий различные классы промежуточного программного обеспечения
* Все классы промежуточного программного обеспечения выполняются в том же порядке, в котором они упоминаются
* Теперь запрос будет перемещен на URL-маршрутизатор. URL-маршрутизатор получает URL-путь из запроса, а затем пытается
  сопоставить с заданными URL-путями в urls.py .
* После сопоставления он вызывает эквивалентную функцию просмотра, откуда генерируется соответствующий ответ.
* Теперь ответ проходит через промежуточное программное обеспечение response и отправляется обратно клиенту / браузеру

**14. В чем разница между select_related и prefetch_related?**

<table class="c24">
  <tbody>
    <tr>
      <td>
        <p>select_related()</p>
      </td>
      <td>
      <p>prefetch_related()</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>Функция select_related() выполняет поиск набора запросов, она добавляет дополнительные данные из ForeignKey в QuerySet.</p>
      </td>
      <td>
        <p>Функция prefetch_related() - это еще один поиск для набора запросов, он добавляет дополнительные данные из ForeignKey, OneToOne и в OneToOne в набор запросов возврата.</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>Это уменьшает фоновый SQL-запрос с использованием операторов JOIN.</p>
      </td>
      <td>
        <p>Он использует SQL joins и команду SELECT, чтобы уменьшить сложный набор запросов.</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>Это работает, когда мы выбираем отдельные объекты.</p>
      </td>
      <td>
        <p>Он используется для выбора набора из нескольких объектов.</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>Пример</p>
        <p>&nbsp;</p>
        <pre>queryset = Blog.objects.select_related(<span>'Author'</span>).all()</pre>
        <p>&nbsp;</p>
        <p>&nbsp;</p>
      </td>
      <td>
        <p>Пример</p>
        <p>&nbsp;</p>
        <pre>queryset = Blog.objects.prefetch_related(<span>'Categories'</span>).all()</pre>
        <p>&nbsp;</p>
        <p>&nbsp;</p>
      </td>
    </tr>
  </tbody>
</table>

Пример:

```python
from django.db import models


class Country(models.Model):
   country_name = models.CharField(max_length=5)
   
   
class State(models.Model):
   state_name = models.CharField(max_length=5)
   country = model.ForeignKey(Country)
   
   
>> states = State.objects.select_related('country').all()
>> for state in states:
...   print(state.state_name)  

#=> SELECT state_id, state_name, country_name FROM State INNER JOIN Country ON (State.country_id = Country.id)

>> country = Country.objects.prefetch_related('state').get(id=1)
>> for state in country.state.all():
...   print(state.state_name)

#=> SELECT id, country_name FROM country WHERE id=1;
#=> SELECT state_id, state_name WHERE State WHERE country_id IN (1);
```

**15. Что такое FBV и CBV?**

Ответ:

* FBV（function base views）- Это использование функции в представлении для обработки запроса.
* CBV（class base views）- Это использование класса в представлении для обработки запроса.

**16. В чём разница между файлом cookie и сеансом**

Ответ:

* **Cookie** - это пара "ключ-значение", хранящаяся в браузере, которая может использоваться для аутентификации
  пользователя.
* **Session** - сохранить информацию о сеансе пользователя на сервере, значение ключа - это случайно сгенерированная
  строка, а значение value - это содержимое сеанса.
  использует файлы cookie для сохранения случайной строки каждого пользователя в браузере пользователя.

**17. Где хранятся сессии в Django?**

Ответ:

Сессия в Django по умолчанию сохраняется в базе данных: таблица django_session

**18. Что такое WSGI?**

Ответ:

WSGI - это метод обработки, предписанный Python при обработке HTTP-запросов. Если приходит HTTP-запрос, есть
соответствующая функция обработки для обработки и возврата результата. WSGI указывает, как выглядят параметры этой
функции обработки и как выглядит результат ее возврата? Что касается имени и логики обработки функции обработки, это не
имеет значения. Проще говоря, WSGI определяет формат ввода и вывода функции обработки.

**19. Что такое csrf token?**

Ответ:

Тег {% csrf_token %} содержит встроенную в Django функцию защиты от подделки межсайтовых запросов (CSRF) (документация
Django). Обычно этот тег добавляется в каждый элемент, для которого используются методы запросов POST, PUT или delete,
такой как форма. С помощью функции отображения в шаблон (render) затем вставляются необходимые средства защиты.

**20. Что вам больше всего нравится в Django?**

Ответ: по желанию

**21. Что вам больше всего не навится в Django?**

Ответ: по желанию

SQL
---

**1. Что подразумевается под СУБД? Какие существуют типы СУБД?**

Ответ:

База данных — структурированная коллекция данных. Система управления базами данных (СУБД) — программное обеспечение,
которое взаимодействует с пользователем, приложениями и самой базой данных для сбора и анализа данных. СУБД позволяет
пользователю взаимодействовать с базой данных. Данные, хранящиеся в базе данных, могут быть изменены, извлечены и
удалены. Они могут быть любых типов, таких как строки, числа, изображения и т. д

**Существует два типа СУБД**:

* Реляционная система управления базами данных: данные хранятся в отношениях (таблицах). Пример — MySQL.
* Не реляционная система управления базами данных: не существует понятия отношений, кортежей и атрибутов. Пример —
  Mongo.

**2. В чем разница между SQL и MySQL?**

Ответ:

SQL — стандартный язык структурированных запросов (Structured Query Language) на основе английского языка, тогда как
MySQL — система управления базами данных.

SQL — язык реляционной базы данных, который используется для доступа и управления данными,
MySQL — реляционная СУБД (система управления базами данных), так же как и SQL Server, Informix и т. д.

**3. Из каких подмножеств состоит SQL?**

Ответ:

* DDL (Data Definition Language, язык описания данных) — позволяет выполнять различные операции с базой данных, такие
  как CREATE (создание), ALTER (изменение) и DROP (удаление объектов).
* DML (Data Manipulation Language, язык управления данными) — позволяет получать доступ к данным и манипулировать ими,
  например, вставлять, обновлять, удалять и извлекать данные из базы данных.
* DCL (Data Control Language, язык контролирования данных) — позволяет контролировать доступ к базе данных. Пример —
  GRANT (предоставить права), REVOKE (отозвать права).

**4. Что такое TRUNCATE и чем эта команда отличается от DELETE?**

Ответ:

<table>
  <thead>
    <tr>
      <th>DELETE</th>
      <th>TRUNCATE</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Используется для удаления строки в таблице</td>
      <td>Используется для удаления всех строк из таблицы</td>
    </tr>
    <tr>
      <td>Вы можете восстановить данные после удаления</td>
      <td>Вы не можете восстановить данные (прим. перевод.: операции логируются по разному, но в SQL Server есть возможность сделать откат) транзакции)</td>
    </tr>
    <tr>
      <td>DML-команда</td>
      <td>DDL-команда</td>
    </tr>
    <tr>
      <td>Медленнее, чем оператор TRUNCATE</td>
      <td>Быстрее</td>
    </tr>
  </tbody>
</table>

**5. Что такое соединения в SQL?**

Ответ:

Для соединения строк из двух или более таблиц на основе связанного между ними столбца используется оператор JOIN. Он
используется для объединения двух таблиц или получения данных оттуда. В SQL есть 4 типа соединения, а именно:

* Inner Join (Внутреннее соединение)
* Right Join (Правое соединение)
* Left Join (Левое соединение)
* Full Join (Полное соединение)

**6. В чем разница между типом данных CHAR и VARCHAR в SQL?**

Ответ:

И Char, и Varchar служат символьными типами данных, но varchar используется для строк символов переменной длины, тогда
как Char используется для строк фиксированной длины. Например, char(10) может хранить только 10 символов и не сможет
хранить строку любой другой длины, тогда как varchar(10) может хранить строку любой длины до 10, т.е. например 6, 8 или
3

**7. Что такое первичный ключ (Primary key)?**

Ответ:

Первичный ключ — столбец или набор столбцов, которые однозначно идентифицируют каждую строку в таблице.
Однозначно идентифицирует одну строку в таблице
Нулевые (Null) значения не допускаются

**8. Что такое ограничения (Constraints)?**

Ответ:

Ограничения (constraints) используются для указания ограничения на тип данных таблицы. Они могут быть указаны при
создании или изменении таблицы. Пример ограничений:

* NOT NULL
* CHECK
* DEFAULT
* UNIQUE
* PRIMARY KEY
* FOREIGN KEY

**9. Что такое уникальный ключ (Unique key)?**

Ответ:

* Однозначно идентифицирует одну строку в таблице.
* Допустимо множество уникальных ключей в одной таблице.
* Допустимы NULL-значения (прим. перевод.: зависит от СУБД, в SQL Server значение NULL может быть добавлено только один
  раз в поле с UNIQUE KEY).

**10. Что подразумевается под целостностью данных?**

Ответ:

Целостность данных определяет точность, а также согласованность данных, хранящихся в базе данных. Она также определяет
ограничения целостности для обеспечения соблюдения бизнес-правил для данных, когда они вводятся в приложение или базу
данных.

**11. В чем разница между кластеризованным и некластеризованным индексами в SQL?**

Ответ:

Различия между кластеризованным и некластеризованным индексами в SQL:

* Кластерный индекс используется для простого и быстрого извлечения данных из базы данных, тогда как чтение из
  некластеризованного индекса происходит относительно медленнее.
* Кластеризованный индекс изменяет способ хранения записей в базе данных — он сортирует строки по столбцу, который
  установлен как кластеризованный индекс, тогда как в некластеризованном индексе он не меняет способ хранения, но
  создает
  отдельный объект внутри таблицы, который указывает на исходные строки таблицы при поиске.
* Одна таблица может иметь только один кластеризованный индекс, тогда как некластеризованных у нее может быть много.

**12. Что такое денормализация и что вы подразумеваете под денормализацией?**

Ответ:

**Денормализация** — техника, которая используется для преобразования из высших к низшим нормальным формам. Она помогает
разработчикам баз данных повысить производительность всей инфраструктуры, поскольку вносит избыточность в таблицу. Она
добавляет избыточные данные в таблицу, учитывая частые запросы к базе данных, которые объединяют данные из разных таблиц
в одну таблицу.

**13. Что такое индекс?**

Ответ:

Индексы относятся к методу настройки производительности, позволяющему быстрее извлекать записи из таблицы. Индекс
создает отдельную структуру для индексируемого поля и, следовательно, позволяет быстрее получать данные.

**14. Опишите различные типы индексов.**

Ответ:

Есть три типа индексов, а именно:

* Уникальный индекс (Unique Index): этот индекс не позволяет полю иметь повторяющиеся значения, если столбец
  индексируется уникально. Если первичный ключ определен, уникальный индекс может быть применен автоматически.
* Кластеризованный индекс (Clustered Index): этот индекс меняет физический порядок таблицы и выполняет поиск на основе
  значений ключа. Каждая таблица может иметь только один кластеризованный индекс.
* Некластеризованный индекс (Non-Clustered Index): не изменяет физический порядок таблицы и поддерживает логический
  порядок данных. Каждая таблица может иметь много некластеризованных индексов.

**15. Что такое нормализация и каковы ее преимущества?**

Ответ:

Нормализация — процесс организации данных, цель которого избежать дублирования и избыточности.

Некоторые из преимуществ:

* Лучшая организация базы данных
* Больше таблиц с небольшими строками
* Эффективный доступ к данным
* Большая гибкость для запросов
* Быстрый поиск информации
* Проще реализовать безопасность данных
* Позволяет легко модифицировать
* Сокращение избыточных и дублирующихся данных
* Более компактная база данных
* Обеспечивает согласованность данных после внесения изменений**

**16. Что такое свойство ACID в базе данных?**

Ответ:

**ACID** означает:

* **Atomicity** - Атомарность
* **Consistency** - Согласованность
* **Isolation** - Изолированность
* **Durability** - Долговечность

Он используется для обеспечения надежной обработки транзакций данных в системе базы данных.

* **Атомарность**. Гарантирует, что транзакция будет полностью выполнена или потерпит неудачу, где транзакция
  представляет
  одну логическую операцию данных. Это означает, что при сбое одной части любой транзакции происходит сбой всей
  транзакции
  и состояние базы данных остается неизменным.

* **Согласованность**. Гарантирует, что данные должны соответствовать всем правилам валидации. Проще говоря, вы можете
  сказать, что ваша транзакция никогда не оставит вашу базу данных в недопустимом состоянии.

* **Изолированность**. Основной целью изолированности является контроль механизма параллельного изменения данных.

* **Долговечность**. Долговечность подразумевает, что если транзакция была подтверждена (COMMIT), произошедшие в рамках
  транзакции изменения сохранятся независимо от того, что может встать у них на пути (например, потеря питания, сбой или
  ошибки любого рода).

**17. Какие виды изолированности есть в SQL?**

Ответ:

* Read uncommitted (Чтение незафиксированных данных). Самый низкий уровень изолированности. На этом уровне транзакции
  изолированы только в такой степени, чтобы нельзя было читать физически поврежденные данные.
* Read committed (Чтение фиксированных данных). Принятый по умолчанию уровень для SQL Server. На этом уровне разрешается
  чтение только фиксированных данных. (Фиксированные данные – это данные, которые стали постоянной частью базы данных.)
* Repeatable read (Повторяемость чтения). Уровень, при котором чтение одной и той же строки или строк в транзакции дает
  одинаковый результат. (Пока транзакция не завершена, никакие другие транзакции не могут модифицировать эти данные.)
* Serializable (Упорядочиваемость). Самый высокий уровень изолированности; транзакции полностью изолируются друг от
  друга. На этом уровне результаты параллельного выполнения транзакций для базы данных совпадают с последовательным
  выполнением тех же транзакций (по очереди в каком-либо порядке).

**18. Что такое «триггеры» в SQL?**

Ответ:

Триггер в SQL — особый тип хранимых процедур, которые предназначены для автоматического выполнения в момент или после
изменения данных. Это позволяет вам выполнить пакет кода, когда вставка, обновление или любой другой запрос выполняется
к определенной таблице.

**19. Что такое подзапрос в SQL?**

Ответ:

**Подзапрос** — это запрос внутри другого запроса, в котором определен запрос для извлечения данных или информации из
базы
данных. В подзапросе внешний запрос называется основным запросом, тогда как внутренний запрос называется подзапросом.
Подзапросы всегда выполняются первыми, а результат подзапроса передается в основной запрос. Он может быть вложен в
SELECT, UPDATE или любой другой запрос. Подзапрос также может использовать любые операторы сравнения, такие как >, <
или =.

**20. Какие бывают типы подзапросов?**

Ответ:

Существует два типа подзапросов, а именно: коррелированные и некоррелированные.

* Коррелированный подзапрос: это запрос, который выбирает данные из таблицы со ссылкой на внешний запрос. Он не
  считается
  независимым запросом, поскольку ссылается на другую таблицу или столбец в таблице.
* Некоррелированный подзапрос: этот запрос является независимым запросом, в котором выходные данные подзапроса
  подставляются в основной запрос.

Объектно-ориентированное программирование
---

**1. Что такое ООП?**

Ответ:

ООП (объектно-ориентированное программирование) — это тип программирования, основанный на объектах, а не только на
функциях и процедурах. Отдельные объекты сгруппированы в классы. ООП внедряет в программирование реальные парадигмы,
такие как наследование, полиморфизм, инкапсуляция и т. д. ООП также позволяет связывать данные и код вместе.

**2. Зачем использовать ООП?**

Ответ:

* ООП обеспечивает ясность в программировании и, следовательно, простоту в решении сложных задач.
* Код может быть повторно использован посредством наследования, тем самым уменьшая избыточность
* Данные и код связаны вместе инкапсуляцией
* ООП позволяет скрывать данные, поэтому личные данные остаются конфиденциальными
* Проблемы могут быть разделены на мелкие части, что облегчает их решение
* Концепция полиморфизма придает программе гибкость, позволяя объектам иметь несколько форм.

**3. Назовите основные принципы ООП**

Ответ:

* Наследование
* Инкапсуляция
* Полиморфизм
* Абстракция

**4. Что такое наследование?**

Ответ:

**Наследование** — это особенность ООП, которая позволяет классам наследовать общие свойства от других классов.
Например,
если существует такой класс, как «транспортное средство», другие классы, такие как «автомобиль», «велосипед» и т. д.,
Могут наследовать общие свойства от класса транспортного средства. Это свойство помогает вам избавиться от избыточного
кода, тем самым уменьшая общий размер кода.

**5. Какие бывают виды наследования?**

Ответ:

* Единственное наследование
* Множественное наследование
* Многоуровневое наследование
* Иерархическое наследование
* Гибридное наследование

**6. Что такое полиморфизм?**

Ответ:

**Полиморфизм** — способность существовать в нескольких формах. Несколько определений могут быть объявлены для одного
интерфейса. Например, если у вас есть класс с именем «Автомобиль», у него может быть метод с именем speed, но вы не
можете определить его, потому что разные машины имеют разную скорость. Этот метод будет определен в подклассах с
разными определениями для разных транспортных средств.

**7. Что такое инкапсуляция?**

Ответ:

**Инкапсуляция** — это связывание данных и кода, который работает с этими данными. Например, класс. Инкапсуляция также
позволяет скрывать данные, так как данные, указанные в одном классе, скрыты от других классов.

**8. Что такое абстракция данных?**

Ответ:

Абстракция данных является очень важной особенностью ООП, которая позволяет отображать только важную информацию и
скрывать детали реализации. Например, когда вы едете на велосипеде, вы знаете, что если надавить на газ, скорость
увеличится, но вы не знаете, как это происходит на самом деле. Это абстракция данных, поскольку детали реализации скрыты
от гонщика.

**9. Как добиться абстракции данных?**

Ответ:

Абстрагирование данных может быть достигнуто через:

* Абстрактный класс
* Абстрактный метод

**10. В чем разница между классом и структурой**

Ответ:

* **Класс**: определенный пользователем проект, из которого создаются объекты. Он состоит из методов или набора
  инструкций,
  которые должны выполняться над объектами.
* **Структура**: пользовательский набор переменных разных типов данных.

**11. Можете ли вы вызвать метод базового класса, не создавая экземпляр?**

Ответ:

Да, вы можете вызывать базовый класс без его создания, если:

Это статический метод
Базовый класс наследуется некоторым другим подклассом

**12. Что такое дескрипторы данных?**

Ответ:

**Дескриптор** - такой атрибут объекта, поведение которого переопределяется специальными методами. Проще говоря, доступ
к
какому-то свойству экземпляра можно переопределить с учетом дополнительных проверок. Если делать эти верификации без
дескрипторов, то один и тот же код начнет повторяться.

Существует 4 метода протокола дескрипторов:

* \_\_get__() - получить значение свойства;
* \_\_set__() - задать значение;
* \_\_delete__() - удалить атрибут;
* \_\_set_name__() - присвоить имя свойству (появился в Питоне версии 3.6).

Лучшие практики
--------------

**1. Что такое YAGNI?**

Ответ:

You Aren’t Gonna Need It / Вам это не понадобится

Этот принцип прост и очевиден, но ему далеко не все следуют. Если пишете код, то будьте уверены, что он вам понадобится.
Не пишите код, если думаете, что он пригодится позже.

Этот принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять
лишние методы. Даже если раньше они были полезны – теперь они не нужны.

Может наступить день, когда они снова понадобятся – тогда вы сможете воспользоваться git-репозиторием, чтобы воскресить
их из мертвых.

**2. Что такое DRY?**

Ответ:

Don’t Repeat Yourself / Не повторяйтесь

Эта концепция была впервые сформулирована в книге Энди Ханта и Дэйва Томаса «Программист-прагматик: путь от подмастерья
к мастеру».

Идея вращается вокруг единого источника правды (single source of truth — SSOT). Что это вообще такое?

```
В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования
информационных моделей и схемы данных, которая подразумевает, что все фрагменты данных обрабатываются (или
редактируются) только в одном месте... SSOT предоставляют достоверные, актуальные и пригодные к использованию данные.

– Википедия
```

Использование SSOT позволит создать более прочную и понятную кодовую базу.

Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код
сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.

В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите
прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом
месте. Повторное использование кода – всегда разумное решение.

**3. Что такое KISS?**

Ответ:

Keep It Simple, Stupid / Будь проще

Этот принцип был разработан ВМС США в 1960 году. Этот принцип гласит, что простые системы будут работать лучше и
надежнее.

У этого принципа много общего с переизобретением колеса, которым занимались в 1970-х. Тогда он звучал как деловая и
рекламная метафора.

Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется.

Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода –
это прекрасно.

Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что
они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что
они подходят для работы.

**4. Что такое BDUF(Big Design Up Front)?**

Ответ:

Глобальное проектирование прежде всего

Этот подход к разработке программного обеспечения очень важен, и его часто игнорируют. Прежде чем переходить к
реализации, убедитесь, что все хорошо продумано.

```
Зачастую продумывание решений избавляло нас от проблем при разработке… Внесение изменений в спецификации занимало час
или два. Если бы мы вносили эти изменения в код, на это уходили бы недели. Я даже не могу выразить, насколько сильно я
верю в важность проектирования перед реализацией, хотя адепты экстремального программирования предали эту практику
анафеме. Я экономил время и делал свои продукты лучше, используя BDUF, и я горжусь этим фактом, чтобы там ни говорили
фанатики экстремального программирования. Они просто ошибаются, иначе сказать не могу.

— Джоел Спольски
```

Многие разработчики считают, что если они не пишут код, то они не добиваются прогресса. Это неверный подход. Составив
план, вы избавите себя от необходимости раз за разом начинать с нуля.

Иногда в недостатках и процессах разработки архитектуры должны быть замешаны и другие люди. Чем раньше вы все это
обсудите, тем лучше будет для всех.

Очень распространенный контраргумент заключается в том, что стоимость решения проблем зачастую ниже стоимости времени
планирования. Чем с меньшим количеством ошибок столкнется пользователь, тем лучше будет его опыт. У вас может не быть
другого шанса справиться с этими ошибками.

**5. Что такое SOLID?**

Ответ:

Это наиболее известный принцип разработки ПО.

**Solid** — это аббревиатура от:

**S) Single-responsibility principle /Принцип единственной ответственности**

Его важность невозможно переоценить. Каждый объект, класс и метод должны отвечать только за что-то одно. Если ваш
объект/класс/метод делает слишком много, вы получите спагетти-код.

Вот пример:

```javascript
const saveTodo = async () => {
    try {
        response = await saveTodoApi();
        showSuccessPop('Success');
        window.location.href = '/successPage';
    } catch (error) {
        showErrorPopup(`Error: ${error} `);
    }
}
```

Этот метод кажется безобидным, но на самом деле он делает слишком много:

1. Сохраняет объект
2. Обрабатывает уведомление в UI
3. Выполняет навигацию

Еще один побочный эффект такого кода – проблемы с тестированием. Запутанный функционал тестировать сложно.

**O) Open–closed principle / Принцип открытости-закрытости**

Программные объекты должны быть открыты для расширения, но закрыты для модификации. Речь о том, что нельзя
переопределять методы или классы, просто добавляя дополнительные функции по мере необходимости.

Хороший способ решения этой проблемы – использование наследования. В JavaScript эта проблема решается с помощью
композиции.

Простое правило: если вы изменяете сущность, чтобы сделать ее расширяемой, вы впервые нарушили этот принцип.

**L) Liskov substitution principle / Принцип подстановки Лисков**

Этот принцип гласит, что объекты старших классов должны быть заменимы объектами подклассов, и приложение при такой
замене должно работать так, как ожидается.

**I) Interface segregation principle / Принцип разделения интерфейсов**

Этот принцип был сформулирован Робертом Мартином, когда он консультировал Xerox, и он очевиден.

Объекты не должны зависеть от интерфейсов, которые они не используют

ПО должно разделяться на независимые части. Побочные эффекты необходимо сводить к минимуму, чтобы обеспечивать
независимость.

Убедитесь, что вы не заставляете объекты реализовывать методы, которые им никогда не понадобятся.

Вот пример:

```typescript
interface Animal {
    eat: () => void;
    walk: () => void;
    fly: () => void;
    swim: () => void;
}
```

Не все животные могут fly, walk или swim, поэтому эти методы не должны быть частью интерфейса или должны быть
необязательными.

**D) Dependency inversion principle / Принцип инверсии зависимостей**

Этот принцип невозможно переоценить. Мы должны полагаться на абстракции, а не на конкретные реализации. Компоненты ПО
должны иметь низкую связность и высокую согласованность.

Заботиться нужно не о том, как что-то устроено, а о том, как оно работает. Простой пример – использование дат в
JavaScript. Вы можете написать для них свой слой абстракции. Тогда если у вас сменится источник получения дат, вам нужно
будет внести изменения в одном месте, а не в тысяче.

Иногда добавление этого уровня абстракции требует усилий, но в конечном итоге они окупаются.

В качестве примера взгляните на date-io, в этой библиотеке создан тот уровень абстракции, который позволяет вам
использовать её с разными источниками дат.

**6. Avoid Premature Optimization**

Ответ:

Избегайте преждевременной оптимизации

Эта практика побуждает разработчиков оптимизировать код до того, как необходимость этой оптимизации будет доказана.
Думаю, что если вы следуете KISS или YAGNI, вы не попадетесь на этот крючок.

Поймите правильно, предвидеть, что произойдет что-то плохое – это хорошо. Но прежде чем вы погрузитесь в детали
реализации, убедитесь, что эти оптимизации действительно полезны.

Очень простой пример – масштабирование. Вы не станете покупать 40 серверов из предположения, что ваше новое приложение
станет очень популярным. Вы будете добавлять серверы по мере необходимости.

Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод
функций на рынок.

Многие считают преждевременную оптимизацию корнем всех зол.

**7. Бритва Оккама**

Ответ:

```
Бри́тва О́ккама (иногда ле́звие О́ккама) — методологический принцип, 
в кратком виде гласящий: «Не следует множить сущее без необходимости» 
(либо «Не следует привлекать новые сущности без крайней на то необходимости»).

— Википедия
```

Что это значит в мире программирования? Не создавайте ненужных сущностей без необходимости. Будьте прагматичны —
подумайте, нужны ли они, поскольку они могут в конечном итоге усложнить вашу кодовую базу.

**8. Паттерны проектирования.**

Ответ: тут вопросы по желанию

Архитектура
------------

**1. Что вы знаете о микросервисах?**

Ответ:

Микросервисы, также известные как архитектура микросервисов, - это архитектурный стиль, в котором приложения создаются
как набор небольших автономных сервисов, смоделированных на основе бизнес-доменов.

Проще говоря, вы должны увидеть, как пчелы строят свои соты, выравнивая шестиугольные восковые соты. Они начали с
использования мелких деталей из различных материалов и продолжили строить из них большой улей. Эти ячейки образуют узор,
создавая прочную структуру, которая удерживает вместе определенные части сот. Здесь каждая ячейка не зависит от другой
ячейки, но также связана с другими ячейками. Это означает, что повреждение одной клетки не повреждает другие клетки,
поэтому пчелы могут восстановить эти клетки, не затрагивая неповрежденные ульи.

**2. В чем преимущества микросервисной архитектуры?**

Ответ:

* Независимая разработка - все микросервисы можно легко разрабатывать в соответствии с их функциями
* Независимое развертывание на основе своих сервисов, их можно развернуть отдельно в любом приложении
* Изоляция сбоев - даже если служба приложения не работает, система может продолжать работать
* Стек гибридных технологий - разные языки и технологии могут использоваться для создания разных сервисов одного и того
  же приложения.
* Гранулярное масштабирование - отдельный компонент можно масштабировать по мере необходимости, нет необходимости
  масштабировать все компоненты вместе

**3. Как работает микросервисная архитектура?**

Ответ:

![Example](https://russianblogs.com/images/857/f82a84a02a55f882881e997d32956c59.JPEG)

* Клиент: разные пользователи с разных устройств отправляют запросы.
* Поставщики удостоверений - проверяют личность пользователей или клиентов и выпускают токены безопасности.
* API-интерфейс для обработки клиентских запросов.
* Статическое содержимое - содержит все содержимое системы.
* Управление балансировкой сервисов на узлах и выявление сбоев.
* Обнаружение служб - руководство по поиску путей связи между микросервисами.
* Content Delivery Network - распределенная сеть прокси-серверов и их центров обработки данных.
* Удаленное обслуживание - Обеспечьте удаленный доступ к информации, хранящейся в сети ИТ-оборудования

**4. Монолитная, в чем разница между SOA и микросервисной архитектурой?**

Ответ:

* Монолитная архитектура похожа на большой контейнер, в котором собраны и плотно упакованы все программные компоненты
  приложения.
* Сервис-ориентированная архитектура - это набор взаимодействующих между собой сервисов. Коммуникация может включать
  простую передачу данных или может включать две или более службы, которые координируют определенные действия.
* Архитектура микросервисов - это архитектурный стиль, при котором приложения создаются как набор небольших автономных
  сервисов, смоделированных на основе бизнес-доменов.

**5. Что такое REST / RESTFUL и какова его цель?**

Передача репрезентативного состояния (REST) / Веб-служба RESTFUL - это архитектурный стиль, который помогает
компьютерным системам обмениваться данными через Интернет. Это упрощает понимание и реализацию микросервисов.

Микросервисы могут быть реализованы с API-интерфейсами RESTFUL или без них, но всегда проще создавать слабосвязанные
микросервисы с использованием API-интерфейсов RESTFUL.

**6. Что такое SPA?**

Ответ:

SPA (одностраничное приложение) было введено для преодоления традиционных ограничений и достижения плавной работы
приложения, интуитивно понятного и интерактивного взаимодействия с пользователем. Вместо загрузки новой страницы SPA
загружают одну веб-страницу и перезагружают запрошенные данные на той же странице с динамически обновляемым содержимым.
Остальная часть веб-страницы остается нетронутой. SPA разрабатываются на стороне клиента с использованием фреймворков
JavaScript, так как вся логика всегда переносится на фронтенд.

**7. Что такое HTTP?**

Ответ:

**HTTP(HyperText Transfer Protocol)** — протокол прикладного уровня; аналогичными ему являются FTP и SMTP. Обмен
сообщениями
идёт по схеме «запрос-ответ». Для идентификации ресурсов HTTP использует глобальные URI. В отличие от многих других
протоколов, HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами
«запрос-ответ». Компоненты, использующие HTTP, могут самостоятельно осуществлять сохранение информации о состоянии,
связанной с последними запросами и ответами (например, «куки» на стороне клиента, «сессии» на стороне сервера).

API многих программных продуктов также подразумевает использование HTTP для передачи данных — сами данные при этом могут
иметь любой формат, например, XML или JSON.

**8. Какая структура HTTP запроса?**

Ответ:

HTTP запрос состоит из трех основных частей, которые идут в нем именно в том порядке, который указан ниже. Между
заголовками и телом сообщения находится пустая строка (в качестве разделителя), она представляет собой символ перевода
строки.

* Строка запроса – указывает метод передачи, URI к которому нужно обратиться и версию протокола HTTP, пример: GET /
  HTTP/1.1
* Заголовки – описывают тело сообщений, передают различные параметры и др. сведения и информацию.
* Пустая строка (разделитель)
* Тело сообщения — это сами данные, которые передаются в запросе. Тело сообщения – это необязательный параметр и может
  отсутствовать.

```http request
POST /cgi-bin/process.cgi HTTP/1.1
User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: length
Accept-Language: ru-ru
Accept-Encoding: gzip, deflate
Connection: Keep-Alive

licenseID=string&content=string&/paramsXML=string
```

**9. Какая структура HTTP ответа?**

Ответ:

HTTP/Версия Код состояния Пояснение

**Код состояния** (Status Code) — три цифры (первая из которых указывает на класс состояния), которые определяют
результат
совершения запроса. Например, в случае, если был использован метод GET, и сервер предоставляет ресурс с указанным
идентификатором, то такое состояние задаётся с помощью кода 200. Если сервер сообщает о том, что такого ресурса не
существует — 404. Если сервер сообщает о том, что не может предоставить доступ к данному ресурсу по причине отсутствия
необходимых привилегий у клиента, то используется код 403. Спецификация HTTP 1.1 определяет 40 различных кодов HTTP, а
также допускается расширение протокола и использование дополнительных кодов состояний.

Пояснение к коду состояния (Reason Phrase) — текстовое (но не включающее символы CR и LF) пояснение к коду ответа,
предназначено для упрощения чтения ответа человеком. Пояснение может не учитываться клиентским программным обеспечением,
а также может отличаться от стандартного в некоторых реализациях серверного ПО.

После стартовой строки следуют заголовки, а также тело ответа.

Например:

```http request
HTTP/1.1 200 OK
Server: nginx/1.2.1
Date: Sat, 08 Mar 2014 22:53:46 GMT
Content-Type: application/octet-stream
Content-Length: 7
Last-Modified: Sat, 08 Mar 2014 22:53:30 GMT
Connection: keep-alive
Accept-Ranges: bytes

Wisdom
```

Тело ответа следует через два переноса строки после последнего заголовка. Для определения окончания тела ответа
используется значение заголовка Content-Length (в данном случае ответ содержит 7 восьмеричных байтов: слово «Wisdom» и
символ переноса строки).

**10. Что такое HTTP метод**

Ответ:

Http Метод представляет собой последовательность из любых символов, кроме управляющих и разделителей, и определяет
операцию, которую нужно осуществить с указанным ресурсом.

**11. Какие HTTP методы вы знаете?**

Ответ:

**GET**:
<details>
  <summary>Пояснение</summary>

  <div>
  Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В
  этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.

Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»: GET
/path/resource?param1=value1&param2=value2 HTTP/1.1

Согласно стандарту HTTP, запросы типа GET считаются идемпотентными

Кроме обычного метода GET, различают ещё

Условный GET — содержит заголовки If-Modified-Since, If-Match, If-Range и подобные;
Частичный GET — содержит в запросе Range.
Порядок выполнения подобных запросов определён стандартами отдельно.
  </div>
</details>

**HEAD**:
<details>
  <summary>Пояснение</summary>

  <div>
    Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для
    извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего
    обращения.
    Заголовки ответа могут кэшироваться. При несовпадении метаданных ресурса с соответствующей информацией в кэше — копия
    ресурса помечается как устаревшая.
  </div>
</details>

**POST**:
<details>
  <summary>Пояснение</summary>

  <div>
  Применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно могут вводить
  свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу.
  При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью
  метода POST обычно загружаются файлы на сервер.

В отличие от метода GET, метод POST не считается идемпотентным[4], то есть многократное повторение одних и тех же
запросов POST может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная
копия этого комментария).

При результате выполнения 200 (Ok) в тело ответа следует включить сообщение об итоге выполнения запроса. Если был создан
ресурс, то серверу следует вернуть ответ 201 (Created) с указанием URI нового ресурса в заголовке Location.

Сообщение ответа сервера на выполнение метода POST не кэшируется.
  </div>
</details>

**PUT**:
<details>
  <summary>Пояснение</summary>

  <div>
  Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурс,
  то
  сервер создаёт его и возвращает статус 201 (Created). Если же был изменён ресурс, то сервер возвращает 200 (Ok) или
  204 (No Content). Сервер не должен игнорировать некорректные заголовки Content-*, передаваемые клиентом вместе с
  сообщением. Если какой-то из этих заголовков не может быть распознан или не допустим при текущих условиях, то
  необходимо
  вернуть код ошибки 501 (Not Implemented).

Фундаментальное различие методов POST и PUT заключается в понимании предназначений URI ресурсов. Метод POST
предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя PUT,
клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу.
Сообщения ответов сервера на метод PUT не кэшируются.
  </div>
</details>

**PATCH**:
<details>
  <summary>Пояснение</summary>

  <div>
  Аналогично PUT, но применяется только к фрагменту ресурса.
  </div>

</details>

**DELETE**:
<details>
  <summary>Пояснение</summary>

  <div>
  Удаляет указанный ресурс.
  </div>

</details>

**TRACE**:
<details>
  <summary>Пояснение</summary>

  <div>
  Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или
  изменяют в запросе.
  </div>

</details>

**CONNECT**:
<details>
  <summary>Пояснение</summary>

  <div>
  Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно, чтобы содействовать установлению защищённого
  SSL-соединения через нешифрованный прокси.
  </div>

</details>

**12. Какие коды существуют, назовите общие их разделы?**

Используются для определения состояния запроса, разделены на 5 групп. Каждая группа имеет собственный «общий смысл»:

* 1xx — информационные. Они описывают процесс передачи.
* 2xx — успешные. Эти говорят нам об успешной передаче.
* 3xx — перенаправленные. Эти же сигнализируют о перенаправлении запроса.
* 4xx — ошибка клиента. Ошибки в запросе, синтаксисе, хосте обращения и т.д.
* 5xx — ошибка сервера. Ошибки в выполнении запроса, связанные с сервером.

Примеры:

* 200 ОК — означает что всё в порядке, запрос обработан и дан ответ.
* 301 Moved Permanently — означает что нужный документ перенесён на другой URI. Новый адрес указывается в заголовке
  Location.
* 302 Found(v1.1), Moved Temporarily(v1.0) — указывает на то, что нужный документ временно перенесён на другой URI,
  который находится в заголовке Location.
* 400 Bad Request — означает что в запросе допущена синтаксическая ошибка.
* 401 Unauthorized — означает что для доступа нужно пройти аутентификацию.
* 403 Forbidden — не хватает прав доступа для выполнения запроса.
* 404 Not Found — сервер не может найти запрошенный URI.
* 500 Internal Server Error — любая ошибка сервера, если она не подходит под любой другой код ответа.

**13. Что такое Cookie?**

Ответ:

**Ку́ки** — небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент (
обычно веб-браузер) всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных
веб-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователя, на практике обычно
используется для:

* аутентификации пользователя;
* хранения персональных предпочтений и настроек пользователя;
* отслеживания состояния сеанса[en] доступа пользователя;
* ведения статистики о пользователях.

**14. Что такое HTTPS?**

Ответ:

HTTPS (HyperText Transfer Protocol Secure) — расширение протокола HTTP, поддерживающее шифрование. Данные, передаваемые
по протоколу HTTPS, «упаковываются» в криптографический протокол SSL или TLS. В отличие от HTTP, для HTTPS по умолчанию
используется TCP-порт 443.

HTTPS не является отдельным протоколом. Это обычный HTTP, работающий через шифрованные транспортные механизмы TLS. Он
обеспечивает защиту от атак, основанных на прослушивании сетевого соединения — от снифферских атак и атак типа
man-in-the-middle, при условии, что будут использоваться шифрующие средства и сертификат сервера проверен и ему
доверяют.

**15. Чем отличаются HTTP1, HTTP2, HTTP3?**

**HTTP 1.1**

Новым в этой версии был режим «постоянного соединения»(keep-alive): TCP-соединение может оставаться открытым после
отправки ответа на запрос, что позволяет посылать несколько запросов за одно соединение. Клиент теперь обязан посылать
информацию об имени хоста(Host заголовок), к которому он обращается, что сделало возможной более простую организацию
виртуального хостинга.

Достоинства:

* Ниже загрузка ЦПУ и расход памяти (потому как открывается меньше соединений одновременно).
* Можно использовать HTTP pipelining (конвейерную обработку) запросов и ответов.
* Снижает вероятность перегрузки сети (меньше TCP соединений).
* Уменьшает лаги для последующих запросов (не нужно заново устанавливать TCP соединение).
* Ошибки HTTP возвращаются без закрытия соединения — клиенты могут пробовать новые команды, и, если они не
  поддерживаются
* сервером, послать повторный запрос в том же соединении, используя старую семантику.
* Эти достоинства особенно проявляются для защищённых HTTPS соединений, потому что создание защищённого соединения
  требует
* больше процессорного времени и сетевого обмена между клиентом и сервером.

**HTTP 2**

* бинарный, сжатие заголовков;
* мультиплексирование данных;
* приоритизация;
* возможна отмена загрузки;
* server push

Вторая крупная версия сетевого протокола HTTP, используемая для доступа к World Wide Web. Протокол основан на SPDY.

В отличие от текстового HTTP 1.1, HTTP/2 — бинарный. Поэтому протокол более эффективен при парсинге, более компактный
при передаче, подвержен меньшему количеству ошибок.

В HTTP 1.1 браузеры используют множественные подключения к серверу для загрузки веб-страницы, причем количество таких
соединений ограничено. Но это не решает проблему с блокированием канала медленными пакетами. Тогда как в HTTP/2
используется мультиплексирование, которое позволяет браузеру использовать одно соединение TCP для всех запросов. Все
файлы подгружаются параллельно. Запросы и ответы разделяются по фреймам с мета-данными, которые ассоциируют запросы и
ответы. Так что они не перекрывают друг-друга и не вызывают путаницы. При этом ответы получаются по мере их готовности,
следовательно, тяжелые запросы не будут блокировать обработку и выдачу более простых объектов.

Вместе с мультиплексированием появилась приоритезация трафика. Запросам можно назначить приоритет на основе важности и
зависимости. Так что при загрузке веб-страницы браузер будет в первую очередь получать важные данные, CSS-код, к
примеру, а все второстепенное обработается в последнюю очередь.

Протокол HTTP построен таким образом, что при отправке запросов также передаются заголовки, которые содержат
дополнительную информацию. Сервер, в свою очередь, также прикрепляет заголовки к ответам. А учитывая, что веб-страницы
состоят из множества файлов, все заголовки могут занимать приличный объем. Поэтому в HTTP/2 присутствует сжатие
заголовков, которое позволит существенно сократить объем вспомогательной информации, так что браузер сможет отправить
все запросы сразу.

При использовании протокола HTTP 1.1 браузер запрашивает страницу, сервер отправляет в ответ HTML и ждет, пока браузер
его обработает и запросит все необходимые файлы: JavaScript, CSS и фото. Поэтому в новый протокол внедрили интересную
функцию под названием Server Push. Она позволяет серверу сразу же, не дожидаясь ответа веб-браузера, добавить нужные по
его мнению файлы в кэш для быстрой выдачи.

**HTTP3**

Протокол QUIC с 2013 года развивает Google в качестве альтернативы TCP+TLS. Главным преимуществом является снижение
задержек при потере пакетов и уменьшение времени установки и согласования соединений. Технически QUIC представляет собой
надстройку над протоколом UDP. QUIC поддерживает мультиплексирование нескольких соединений, а также методы шифрования,
аналогичные TLS/SSL.

* уровень безопасности, сравнимый с TLS;
* контроль целостности потока с помощью прямой коррекции ошибок, предотвращающей потерю пакетов;
* почти мгновенное установление соединения и возможность сразу после отправки пакета подключения передавать данные, а
* также минимизация задержки между отправкой запроса и получением ответа;
* наличие идентификатора соединения UUID позволит сократить время на переподключение к сетям для перемещающихся
  мобильных
* клиентов;
* избавление от таймаутов за счёт отказа от того же номера последовательности при повторной передаче пакетов;
* разделение на потоки, при котором потеря пакета влияет только на свой поток;
* новая система коррекции ошибок на основе кодов;
* выравнивание криптографических границ блоков с границами пакетов QUIC, что снижает влияние потери пакетов на
* декодирование;
* отсутствие проблем с блокировкой очереди TCP;
* система прогнозирования пропускной способности в каждом направлении, что позволяет уменьшить вероятность возникновения
* перегрузки. Как следствие — рост производительности и пропускной способности, по сравнению с TCP. В частности, для
* YouTube это позволило снизить повторную буферизацию на 30 %.

**16. Что такое RPC?**

Ответ:

Удалённый вызов процедур, реже Вызов удалённых процедур (от англ. Remote Procedure Call, RPC) — класс технологий,
позволяющих компьютерным программам вызывать функции или процедуры в другом адресном пространстве (на удалённых
компьютерах, либо в независимой сторонней системе на том же устройстве). Обычно реализация RPC-технологии включает в
себя два компонента: сетевой протокол для обмена в режиме клиент-сервер и язык сериализации объектов (или структур, для
необъектных RPC). На транспортном уровне RPC используют в основном протоколы TCP и UDP, однако, некоторые построены на
основе HTTP (что нарушает архитектуру ISO/OSI, так как HTTP — изначально не транспортный протокол).

Характерными чертами вызова удалённых процедур являются:

Асимметричность, то есть одна из взаимодействующих сторон является инициатором;
Синхронность, то есть выполнение вызывающей процедуры приостанавливается с момента выдачи запроса и возобновляется
только после возврата из вызываемой процедуры.

**17. Что такое gPRC**

Ответ:

gRPC — фреймворк от Google для удалённого вызова процедур
Введение в gRPC
gRPC в качестве протокола межсервисного взаимодействия. Доклад Яндекса
Python Microservices With gRPC
gRPC — это высокопроизводительный фреймворк разработанный компанией Google для вызов удаленных процедур (RPC), работает
поверх HTTP/2. gRPC простой в использовании, отлично подходит для создания распределенных систем (микросервисов) и API.
Имеет встроенную поддержку для балансировки нагрузки, трассировки, аутентификации и проверки жизнеспособности сервисов.
Есть возможность создавать клиентские библиотеки для работы с бэкендом на 10 языках. Высокая производительность
достигается за счет использования протокола HTTP/2 и Protocol Buffers.

Из коробки имеет:

* Protobuf в качестве инструмента описания типов данных и сериализации. Очень классная и хорошо зарекомендовавшая себя
  на практике штука. Собственно говоря, те, кому была нужна производительность — и раньше брали Protobuf, а дальше уже
  отдельно заморачивались транспортом. Теперь всё в комплекте.
* HTTP/2 в качестве транспорта. И это невероятно мощный ход! Вся прелесть полного сжатия данных, контроля трафика,
  инициации событий с сервера, переиспользования одного cокета для нескольких параллельных запросов — красотища.
* Статические пути — никаких больше «сервис/коллекция/ресурс/запрос? параметр=значение». Теперь только «сервис», а что
  внутри — описывайте в терминах вашей модели и её событий.
* Никакого привязывания методов к HTTP-методам, никакого привязывания возвращаемых значений к HTTP-статусам. Пишите, что
  хотите.
* SSL/TLS, OAuth 2.0, аутентификация через сервисы Google, плюс можно прикрутить свою (например, двухфакторную)
* Поддержка 9-ти языков: C, C++, Java, Go, Node.js, Python, Ruby, Objective-C, PHP, C# плюс, конечно, никто не запрещает
  взять и реализовать свою версию хоть для брейнфака.
* Поддержка gRPC в публичных API от Google. Уже работает для некоторых сервисов. Нет, REST-версии, конечно, тоже
  останутся. Но посудите сами, если у вас будет выбор — использовать, скажем, из мобильного приложения REST-версию,
  отдающие данные за 1 сек или с теми же затратами на разработку взять gRPC-версию, работающую 0.5 сек — что вы
  выберете? А что выберет ваш конкурент?
